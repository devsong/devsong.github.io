<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://devsong.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://devsong.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-03-19T14:45:29+08:00</updated><id>https://devsong.github.io/feed.xml</id><title type="html">devsong’s website</title><subtitle>记录日常学习的代码、问题以及个人对相关技术的一些思考与见解 </subtitle><entry><title type="html">Transaction mvcc lock深入分析</title><link href="https://devsong.github.io/blog/2022/08/001-%E7%9B%AE%E5%BD%95/" rel="alternate" type="text/html" title="Transaction mvcc lock深入分析"/><published>2022-08-20T10:00:04+08:00</published><updated>2022-08-20T10:00:04+08:00</updated><id>https://devsong.github.io/blog/2022/08/001-%E7%9B%AE%E5%BD%95</id><content type="html" xml:base="https://devsong.github.io/blog/2022/08/001-%E7%9B%AE%E5%BD%95/"><![CDATA[<h3 id="mysql-事务mvcc锁">mysql 事务/MVCC/锁</h3> <ul> <li><a href="/blog/2022/08/002-transaction/">01.事务</a> ,介绍事务的一些基础知识,以MySql为示例,演示四种事务隔离级别的用途与用法</li> <li><a href="/blog/2022/08/003-mvcc/">02.MVCC</a>,介绍Copy on Write/Innodb MVCC的相关实现</li> <li><a href="/blog/2022/08/004-lock/">03.Mysql Innodb锁的用法以及相关实现</a>介绍Innodb锁的用法、相关实现</li> </ul>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="index"/><summary type="html"><![CDATA[mysql 事务/MVCC/锁]]></summary></entry><entry><title type="html">事务基础</title><link href="https://devsong.github.io/blog/2022/08/002-transaction/" rel="alternate" type="text/html" title="事务基础"/><published>2022-08-20T10:00:04+08:00</published><updated>2022-08-20T10:00:04+08:00</updated><id>https://devsong.github.io/blog/2022/08/002-transaction</id><content type="html" xml:base="https://devsong.github.io/blog/2022/08/002-transaction/"><![CDATA[<h3 id="传统关系型数据库两类典型的应用场景">传统关系型数据库两类典型的应用场景</h3> <ul> <li>OLTP(On-Line Transaction Processing) 在线交易处理，特点是并发高，写入/读取操作较多，单个事务的数据规模较小(通常情况下在byte/k byte左右)，常见于业务系统</li> <li>OLAP(On-Line Analytical Processing) 在线分析处理，特点是数据量大(单次数据分析的规模基本都在GB级别往上)，无并发，写入频率极低,常见于报表类型的系统</li> </ul> <h3 id="传统事务">传统事务</h3> <p>数据库的事务通常针对单机数据库而言，也是传统意义上的大家熟知的事务，通常情况下需要满足如下四个条件:</p> <ul> <li>A(Atomic): 原子性，所有的语句作为原子工作单元去执行，要么全部执行，要么全部不执行</li> <li>C(Consistent): 一致性，事务完成后，所有数据的状态都是一致的，例如银行转账，a账户转b账户100，a账户扣减100，b账户必须加上100</li> <li>I(Isolation):隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离</li> <li>D(Duration):持久性，即事务完成后，对数据库数据的修改被持久化存储。</li> </ul> <p>持久性与一致性通常较容易理解，原子性与隔离型在数据库事务中的底层实现较复杂</p> <p>通常情况下，数据库的CRUD操作分别对应数据的insert select update delete 四种操作，上述四种操作代表数据库中的四种最基本的原子操作，不可再继续分割，类比于自然界中的化学反应，原子是构成物质的最基本的元素，不可再分割(虽说在物理学中原子可以在进一步分割)</p> <p>注:<strong><em>下述所有的操作使用的MySql版本为5.7.36</em></strong> 理论上来说，5.7.x的版本应该都适用</p> <h3 id="数据库事务">数据库事务</h3> <p>提交型的事务示例</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">begin</span><span class="p">;</span>
	<span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span><span class="o">-</span><span class="mi">100</span> <span class="k">where</span> <span class="n">user_name</span> <span class="o">=</span> <span class="s1">'A'</span><span class="p">;</span> <span class="c1">-- 语句1</span>
	<span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span><span class="o">+</span><span class="mi">100</span> <span class="k">where</span> <span class="n">user_name</span> <span class="o">=</span> <span class="s1">'B'</span><span class="p">;</span> <span class="c1">-- 语句2</span>
<span class="k">commit</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>回滚型的事务示例</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">begin</span><span class="p">;</span>
	<span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span><span class="o">-</span><span class="mi">100</span> <span class="k">where</span> <span class="n">user_name</span> <span class="o">=</span> <span class="s1">'A'</span><span class="p">;</span> <span class="c1">-- 语句1</span>
	<span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span><span class="o">+</span><span class="mi">100</span> <span class="k">where</span> <span class="n">user_name</span> <span class="o">=</span> <span class="s1">'B'</span><span class="p">;</span> <span class="c1">-- 语句2</span>
<span class="k">rollback</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>上述操作即是模拟一个银行账户的转账操作，A-&gt;B账户转账100，将两个语句放到begin/end块中即构成了一个最简单的事物操作，转账操作要么成功，要么失败，不会存在账户A扣款100而账户B增加100失败的场景，在传统的关系型支持事物的数据库中(Oracle/Mysql/SqlServer)，上述事务(ACID特性)由数据库软件保证，开发人员只需要关注上层的业务逻辑，事务特性交由底层的数据库软件保证</p> <h3 id="事务隔离级别">事务隔离级别</h3> <p>在看事物隔离级别之前，先了解下下述三种读取数据常见的名词:</p> <ul> <li>脏读(Dirty Read): 当前事务内允许读取其他事物还未提交的修改</li> <li>不可重复读(NonRepeatable Read):当前事务内同一个查询操作,读取的数据可以发生变化</li> <li>可重复读(Repeatable Read): 当前事务内同一个查询操作,读取的数据不会发生改变</li> <li>幻读(Phantom Read):当前事务内读取到了其他事物insert操作产生的数据</li> </ul> <p>四种事务隔离级别定义</p> <ul> <li>读未提交(Read UnCommited):允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li> <li>读提交(Read Commited):只能读取到其他事物已经提交的数据,未提交的数据无法读取</li> <li>可重复读(Repeatable Read):在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li> <li>串行读(Serializable):完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li> </ul> <p>隔离级别对照表</p> <table> <thead> <tr> <th style="text-align: center">隔离级别</th> <th style="text-align: center">脏读</th> <th style="text-align: center">不可重复读</th> <th style="text-align: center">幻读</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">读未提交</td> <td style="text-align: center">可能</td> <td style="text-align: center">可能</td> <td style="text-align: center">可能</td> </tr> <tr> <td style="text-align: center">读提交</td> <td style="text-align: center">不可能</td> <td style="text-align: center">可能</td> <td style="text-align: center">可能</td> </tr> <tr> <td style="text-align: center">可重复读</td> <td style="text-align: center">不可能</td> <td style="text-align: center">不可能</td> <td style="text-align: center">可能</td> </tr> <tr> <td style="text-align: center">串行读</td> <td style="text-align: center">不可能</td> <td style="text-align: center">不可能</td> <td style="text-align: center">不可能</td> </tr> </tbody> </table> <p>读未提交这种隔离级别不对数据一致性做任何保障,主流生产环境的数据库一般不会使用，串行读会极大降低数据库对于事物的处理能力(所有事物串行执行,读加读锁，写加写锁，读写互斥)， 主流的关系型数据库默认的事务隔离级别要么是RC(SqlServer/Oracle),要么是RR(Mysql)</p> <h3 id="示例表的建表语句">示例表的建表语句</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`account`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="nb">bigint</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`balance`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="s1">'0'</span><span class="p">,</span>
  <span class="nv">`username`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="s1">''</span><span class="p">,</span>
  <span class="nv">`create_time`</span> <span class="nb">datetime</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`update_time`</span> <span class="nb">timestamp</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`idx_username`</span> <span class="p">(</span><span class="nv">`username`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>初始化的一条数据</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">insert</span> <span class="k">into</span> <span class="n">account</span> <span class="k">values</span><span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s1">'alice'</span><span class="p">,</span><span class="n">now</span><span class="p">(),</span><span class="n">now</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="读未提交">读未提交</h3> <p>mysql innodb 存储引擎默认的事物隔离级别为RR(可重复读),在讨论RUC的事物隔离级别的时候需要手动调整session默认的隔离级别</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">read</span> <span class="k">uncommitted</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>关闭session的自动提交功能</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">set</span> <span class="n">autocommit</span><span class="o">=</span><span class="k">off</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>模拟两个并发的场景(并发通常在数据库层面体现的就是两个并发的事物)</p> <table> <thead> <tr> <th>step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th>Session2</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td>begin;</td> </tr> <tr> <td>2</td> <td>tx1</td> <td style="text-align: left">update account set balance = 9,update_time = now() where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>4</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>update account set balance = 8,update_time = now() where id = 1;</td> </tr> <tr> <td>5</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>– waiting until session1 commit or rollback;</td> </tr> <tr> <td>6</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>7</td> <td> </td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>8</td> <td>tx3</td> <td style="text-align: left">begin;</td> <td> </td> <td> </td> </tr> <tr> <td>9</td> <td>tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>10</td> <td>tx3</td> <td style="text-align: left"> </td> <td>tx2</td> <td>commit;</td> </tr> <tr> <td>11</td> <td>tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td> </td> <td> </td> </tr> <tr> <td>12</td> <td>tx3</td> <td style="text-align: left">commit;</td> <td> </td> <td> </td> </tr> </tbody> </table> <p>下述列举了几个关键性环节的select查询语句的输出</p> <ul> <li> <p>step3 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">9</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step7 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">8</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step9 session1 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">8</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step11 session1 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">8</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> </ul> <p>可以看到,在”读未提交”的事物隔离级别下,事务每次都是读取行的最新数据，而不关注事物是否已提交,上述示例咋一看可能没什么特别大的问题，仔细想一下存在下述问题</p> <ul> <li>数据的最终结果取决于tx1/tx2提交的顺序，上述示例演示的实际上是两个并发事物在”读未提交”隔离级别下的一种场景，亦即不确定性增加,这类场景与并发编程中的共享资源未正确同步类似，结果是不确定(亦或者是随机的)</li> <li>上述示例只是演示了两个事物，一条共享数据,当系统中并发事物越多，单事物更新的数据条数越多,最终每条数据更新的结果不确定性就越大，基本上是呈指数级别增加</li> <li>事务不管commit还是rollback，tx2均会读取最新的内容,这种场景对于大部分数据一致性要求较高的场景都无法接受，违反的隔离性的约束</li> </ul> <h3 id="读提交">读提交</h3> <p>调整session的隔离级别为读提交</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">read</span> <span class="k">committed</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>更新数据记录为默认值10</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>模拟两个并发的场景</p> <table> <thead> <tr> <th>step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th>Session2</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td>begin;</td> </tr> <tr> <td>2</td> <td>tx1</td> <td style="text-align: left">update account set balance = balance-1,update_time = now() where balance&gt;0 and id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>update account set balance = balance-1,update_time = now() where balance&gt;0 and id = 1;</td> </tr> <tr> <td>4</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>– waiting unitl session1 commit;</td> </tr> <tr> <td>5</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>6</td> <td> </td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>7</td> <td>tx3</td> <td style="text-align: left">begin;</td> <td> </td> <td> </td> </tr> <tr> <td>8</td> <td>tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>9</td> <td>tx3</td> <td style="text-align: left"> </td> <td>tx2</td> <td>commit;</td> </tr> <tr> <td>10</td> <td>tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td> </td> <td> </td> </tr> <tr> <td>11</td> <td>tx3</td> <td style="text-align: left">commit;</td> <td> </td> <td> </td> </tr> </tbody> </table> <ul> <li> <p>step6 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">8</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step8 session1 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">9</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step10 session1 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">8</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> </ul> <p>可以看到两个session在事物提交前后，读取到的内容是不一样的，</p> <ul> <li>初始阶段，系统里面只有一条初始化的数据，此时session1/session2读到的数据均为初始化的数据，亦即余额=10的那条数据</li> <li>step5 session1 提交更新，此时session1事物(tx1)提交,step6阶段session2输出见上述<strong>step6 session2 输出</strong>，读取到的balance=8</li> <li>step7 session1 开启一个新的事务tx3(上一个tx提交,mysql隐式开启tx)，此时step8 session1(tx3)读取到的内容为balance=9</li> <li>step8 session1 读取id=1的数据，此时tx3读取到的余额为balance=8</li> <li>step9 session2 tx2 提交，step10 session1 tx3 重新读取数据,此时读取到的余额为balance=8</li> </ul> <p>通过上述分析，读提交的事物隔离级别体现在下述2点</p> <ul> <li>step6 session2(tx2)读取的数据为8，此时tx2在不同时间点读取到的内容不一样(初始balance=10，step6 读取到tx1提交的变更)</li> <li>step8 session1(tx3)读取到的数据为9，此时tx2还未提交,读取的数据是tx1已提交的数据</li> <li>step10 session1(tx3)读取到的数据为8，此时tx2已提交，读取到最新的内容，示例与tx1类似</li> </ul> <p>通过上述几点可以观察到对于读提交的事物隔离级别,对于不同事物对同一行的更新，通常情况下由于”锁等待”的存在,两个事物看似像是”串行”执行了一样,更新的总量与总体的事物量相对应,不存在读未提交中的更新丢失，事实上读提交的这种特性符合现实当中的大部分业务场景,这也是Oracle/SqlServer将默认的隔离级别设置为读提交的场景</p> <p>对比读提交与读未提交可以清晰的发现</p> <ul> <li>数据的可见性不在以单条sql语句执行成功与否来决定,而由事务是否提交来决定,通常情况下应用程序开发人员可以控制事物提交的时机，但无法控制单条Sql何时执行成功</li> <li>读提交的大部分场景结果是可控的，尤其是在多个事物中包含多条语句的时候，最终的执行结果取决于最后一个事物执行的结果，从应用程序的维度去看，只需要控制事物的执行顺序就能得到我们想要的结果</li> <li>读提交隔离级别某种程度上违反了上述ACID四特性中的I的要求,亦即隔离性</li> </ul> <h3 id="可重复读">可重复读</h3> <p>设置当前session的事物隔离级别</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">repeatable</span> <span class="k">read</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>更新数据记录为默认值10</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>模拟两个并发的场景</p> <table> <thead> <tr> <th>step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th>Session2</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td>begin;</td> </tr> <tr> <td>2</td> <td>tx1</td> <td style="text-align: left">update account set balance=balance-1,update_time = now() where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>4</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>update account set balance = balance-1,update_time = now() where id = 1;</td> </tr> <tr> <td>5</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>– waiting until session1 commit or rollback;</td> </tr> <tr> <td>6</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>7</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>8</td> <td>tx3</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>9</td> <td>tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>10</td> <td>tx3</td> <td style="text-align: left"> </td> <td>tx2</td> <td>commit;</td> </tr> <tr> <td>11</td> <td>tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td> </td> <td> </td> </tr> <tr> <td>12</td> <td>tx3</td> <td style="text-align: left">commit;</td> <td> </td> <td> </td> </tr> </tbody> </table> <ul> <li> <p>step3 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">10</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step7 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">8</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step9 session1 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">9</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step11 session1 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">9</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> </ul> <p>上述输出需要注意一下几个点</p> <ul> <li>session2 step3 输出的balance是10，并未读取到脏数据(tx1更新的数据)</li> <li>tx1 step2与tx2 step4的两个update操作实际上都存在一个读操作(balance-1),</li> <li>session2 step7 输出的balance是8,看似读取到了tx1的提交，这个跟mvcc以及锁有关系，后续会锁章节会解释</li> <li>session1 tx3 step9 step11 两次读操作体现的就是可重复读,与读提交不同的是tx3 step11与step9两次读取操作不会随着tx2事物的提交而发生变更</li> <li>此处未演示tx2 insert的情形,innodb在repeatable read通过next-key机制解决了幻读问题(标准的事物隔离级别幻读只在Serializable隔离级别才能解决)</li> </ul> <h3 id="串行读serializable">串行读(SERIALIZABLE)</h3> <p>照例设置session的默认隔离级别</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">serializable</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>更新数据记录为默认值10并insert一条新的数据</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">begin</span><span class="p">;</span>
  <span class="k">update</span> <span class="n">account</span> <span class="k">set</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">insert</span> <span class="k">into</span> <span class="n">account</span> <span class="k">values</span><span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s1">'bob'</span><span class="p">,</span><span class="n">now</span><span class="p">(),</span><span class="n">now</span><span class="p">());</span>
<span class="k">commit</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>模拟两个并发的场景</p> <table> <thead> <tr> <th>step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th>Session2</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td>begin;</td> </tr> <tr> <td>2</td> <td>tx1</td> <td style="text-align: left">update account set balance=balance-1,update_time = now() where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>4</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>– waiting until session1 commit or rollback;</td> </tr> <tr> <td>6</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>7</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td>select id,balance,username from account where id = 1;</td> </tr> <tr> <td>8</td> <td> </td> <td style="text-align: left"> </td> <td>tx2</td> <td>update account set balance=balance-1,update_time = now() where id = 1;</td> </tr> <tr> <td>8</td> <td>tx3</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>9</td> <td>tx3</td> <td style="text-align: left">update account set balance=balance-1,update_time = now() where id = 1;</td> <td>tx2</td> <td> </td> </tr> <tr> <td>10</td> <td>tx3</td> <td style="text-align: left">– Deadlock found when trying to get lock; try restarting transaction</td> <td>tx2</td> <td> </td> </tr> <tr> <td>11</td> <td> </td> <td style="text-align: left"> </td> <td>tx2</td> <td>commit;</td> </tr> </tbody> </table> <p>注意下述几个步骤</p> <ul> <li>step2 session1 tx1 有一条更新语句</li> <li>step3 session2 tx2 在读取操作的时候会出现waiing状态,这在前述三种隔离级别未曾发生</li> <li>step6 session1 tx1 commit后，释放行记录上的锁(X锁)，session2 tx2 才可以继续进行</li> <li>step10 session1 tx3 在对记录进行update时候，直接被系统检测到死锁发生,回滚并重新开启新的事物(tx2持有记录id=1的X锁直到ste11才释放)</li> </ul> <p>整体来看,并发场景下对同一个记录行进行操作时，读写操作互斥，需要等待资源上的锁定被释放才能继续执行下一步，而在前述三种事物隔离级别的场景下，两个事物，只有存在并发写才会存在锁等待，读写并不会造成锁等待，默认只有在串行读的事物隔离级别下才会出现读写操作的互斥，锁的兼容性介绍请参见后续innodb关于锁的分析</p>]]></content><author><name></name></author><category term="mysql"/><category term="blogs"/><category term="mysql"/><category term="transaction"/><summary type="html"><![CDATA[传统关系型数据库两类典型的应用场景 OLTP(On-Line Transaction Processing) 在线交易处理，特点是并发高，写入/读取操作较多，单个事务的数据规模较小(通常情况下在byte/k byte左右)，常见于业务系统 OLAP(On-Line Analytical Processing) 在线分析处理，特点是数据量大(单次数据分析的规模基本都在GB级别往上)，无并发，写入频率极低,常见于报表类型的系统]]></summary></entry><entry><title type="html">Innodb MVCC相关介绍与实现</title><link href="https://devsong.github.io/blog/2022/08/003-mvcc/" rel="alternate" type="text/html" title="Innodb MVCC相关介绍与实现"/><published>2022-08-20T10:00:04+08:00</published><updated>2022-08-20T10:00:04+08:00</updated><id>https://devsong.github.io/blog/2022/08/003-mvcc</id><content type="html" xml:base="https://devsong.github.io/blog/2022/08/003-mvcc/"><![CDATA[<h3 id="前言">前言</h3> <p>在介绍MVCC之前,先看一下下述几个知识点</p> <ul> <li>读写操作兼容性</li> <li>Copy on write下数据的读写</li> <li>Undo log使用场景以及用途</li> </ul> <h3 id="常规读写操作兼容性">常规读写操作兼容性</h3> <p>广义上的读写兼容性可以参见:</p> <table> <thead> <tr> <th style="text-align: left">操作类型</th> <th style="text-align: left">读</th> <th style="text-align: left">写</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">读</td> <td style="text-align: left">兼容</td> <td style="text-align: left">不兼容</td> </tr> <tr> <td style="text-align: left">写</td> <td style="text-align: left">不兼容</td> <td style="text-align: left">不兼容</td> </tr> </tbody> </table> <p>可以看到只有两个(多个)操作类型均是读(不涉及数据修改)的时候才能兼容,读写/写写操作均是不兼容(互斥)的,大部分编程语言中的锁算法都遵循上述规则(共享锁/S锁/读锁对应的是数据的读取操作,排它锁/X锁/写锁对应的数据修改操作)</p> <h3 id="copy-on-write算法">Copy On Write算法</h3> <p>Copy On Write(中文翻译为写时复制)技术,COW技术是一种广泛使用在计算机科学中的一门技术(Linux中的fork,java的CopyOnWriteArrayList等)，考虑一下下述个人文件数据确认的场景</p> <ul> <li>假设/home/user/data大小10M,一共10个用户(每个用户平均1M个人数据)，需要确认文件中各自数据是否正确,假设数据正确，就无需修改(仅读操作),数据异常需要更正(写操作)，在假设10个人中数据异常的概率在10%，亦即9个人的数据是对的，1个人的数据需要修复</li> <li>传统的处理流程中,每个人独占的方式打开文件，10个人轮流确认，假设每个人确认数据耗时1小时，那么总体确认完10M数据文件耗时10个小时</li> <li>上述流程中不难发现,90%的概率下用户是不需要进行修改操作的，只有10%的操作需要串行化去处理</li> <li>COW的流程中，10个人默认对于文件均有访问权限(非独占的方式),假设用户1需要修改,那么此时系统会基于原始的数据文件Copy一份副本,用户1确认修改完成后，保存副本，系统将此副本覆盖回原始文件，剩余用户的读操作不受影响</li> <li>可以看到在上述流程中，理论上原本需要10个小时的工作,极限情况下可以缩短到1个小时(10-&gt;1)，系统只需要处理1个写操作的覆盖即可</li> </ul> <p>下述图片展示了一个常见的读写共享文件的步骤</p> <p><img src="/assets/img/mysql/tx_mvcc/origin_rw.png" width="760" height="500" alt="cow.png"/></p> <p>采用COW读写文件的简易流程</p> <p><img src="/assets/img/mysql/tx_mvcc/cow_rw.png" width="760" height="500" alt="cow.png"/></p> <p>COW技术的局限性在于倘若系统中写的比率占比高的话，某种程度上来说用户处理冲突会额外的花费一部分处理时间,以上述场景举例，假定处理冲突的时间耗时1.5H,假设30%冲突的概率(亦即三个用户需要修改)来算，整体的处理流程大概耗时<code class="language-plaintext highlighter-rouge">1h+4.5h = 5.5h</code>,倘若10个人都需要修改,那么原始10个小时的串行处理流程,在使用COW的场景下很有可能演变为<code class="language-plaintext highlighter-rouge">1h+10*1.5h = 16h</code>的场景</p> <p>综上，COW技术适用于系统中<strong>读多写少</strong>这一类的场景，并发写入占比过高的话，某种程度上独占的方式更简单高效</p> <p>COW场景下读写操作的兼容性</p> <table> <thead> <tr> <th style="text-align: left">操作类型</th> <th style="text-align: left">读</th> <th style="text-align: left">写</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">读</td> <td style="text-align: left">兼容</td> <td style="text-align: left">兼容</td> </tr> <tr> <td style="text-align: left">写</td> <td style="text-align: left">兼容</td> <td style="text-align: left">不兼容</td> </tr> </tbody> </table> <p>可以看到在COW下,读写操作是可以兼容的，写写操作仍然是无法兼容的</p> <h3 id="undo-log">Undo Log</h3> <p>传统的事务支持显示的提交/回滚操作,提交操作容易理解，回滚操作与Mysql的undo log段息息相关,undo log在mysql中通常情况下是逻辑日志，根据每行进行记录，下述展示常见的undo log流程</p> <ul> <li>针对select ,不产生undo log,select操作不会对数据产生变更</li> <li>针对insert,产生的undo log 使用delete语句做变更</li> <li>针对update,产生的undo log 用逆向的update语句做变更</li> <li>针对delete,产生的undo log用insert语句做变更</li> </ul> <p>可以看到,针对上述三种修改类型的操作，undo log均会记录行数据的上一个版本,位于undo log中的数据通常称之为快照(历史版本)数据,</p> <p>实际上undo log除了用作rollback外，另外一个重要的使用场景就是MVCC</p> <h3 id="mvcc">MVCC</h3> <p>MVCC(Multi-Version Concurrency Control)的全称是是多版本并发控制，在Innodb的实现中主要是为了提高数据库的并发处理性能,用更好的方式去处理读写冲突，采用非阻塞的方式做到并发读</p> <p>MVCC情况下的读写兼容类型可以参见:</p> <table> <thead> <tr> <th style="text-align: left">操作类型</th> <th style="text-align: left">读</th> <th style="text-align: left">写</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">读</td> <td style="text-align: left">兼容</td> <td style="text-align: left">兼容</td> </tr> <tr> <td style="text-align: left">写</td> <td style="text-align: left">兼容</td> <td style="text-align: left">不兼容</td> </tr> </tbody> </table> <p>可以看到在MVCC下,读写操作是可以兼容的，写写操作仍然是无法兼容的,这点与前述的COW情况一样,在介绍完Copy on write技术以及undo log后，下面来看innodb的MVCC具体流程。</p> <p>默认情况下innodb的MVCC机制仅工作在读提交与可重复读这两种隔离级别下，读未提交/串行读的相关语义均不同程度的无法适用于MVCC</p> <ul> <li>读未提交每次读取均是读取数据的最新版本,不存在读取历史版本这么一说</li> <li>串行读要求读写操作互斥，亦即多个事务对于同一行的操作读写是不兼容的，需要阻塞等待</li> </ul> <p>MVCC情况下的读操作分两种</p> <ul> <li>一致性非锁定读,Mysql默认的读类型，常见的select * from table 即是此类型，通常又称之为快照读</li> <li>一致性锁定读,需要对select操作添加额外的锁来实现，通常亦称之为当前读，锁定读可以继续细分为如下场景 <ul> <li>共享锁定模式(读锁) : select * from table where id = xx lock in share mode;</li> <li>独占锁定模式(写锁) : select * from table where id = xx for update;</li> </ul> </li> </ul> <h5 id="rc隔离级别下的mvcc示例">RC隔离级别下的MVCC示例</h5> <table> <thead> <tr> <th style="text-align: left">step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th style="text-align: left">Session2</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td style="text-align: left">begin;</td> </tr> <tr> <td style="text-align: left">2</td> <td>tx1</td> <td style="text-align: left">update account set balance = balance-1,update_time = now() where balance&gt;0 and id = 1;</td> <td>tx2</td> <td style="text-align: left"> </td> </tr> <tr> <td style="text-align: left">3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> </tr> <tr> <td style="text-align: left">4</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td style="text-align: left"> </td> </tr> <tr> <td style="text-align: left">5</td> <td> </td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> </tr> <tr> <td style="text-align: left">6</td> <td> </td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">commit;</td> </tr> </tbody> </table> <p>对于RC,session2 两次读的数据输出如下:</p> <ul> <li> <p>step3 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">10</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step5 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">9</span>  <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> </ul> <p>MVCC流程大致如下:</p> <ul> <li>session1 step2 tx1 update语句做变更,产生undo log数据,记录数据的上一个版本数据,亦即balance=10</li> <li>session2 step3 tx2 select读取快照数据,此时快照的版本数据即是step2中update操作生成的快照数据</li> <li>session1 step4 tx1 commit数据,最新版本的数据被覆写,这个操作类似于前述的COW的OverWrite操作</li> </ul> <p>读提交场景下，快照读每次读取的都是最新提交的数据,下面用前述的COW视角来分析此操作</p> <ul> <li>针对session1 step2执行了update语句，但是并没有commit,数据修改在copy data的基础上做了修改.</li> <li>针对session2 step3执行了select操作,读取的是原始的origin data文件,此时balance=10</li> <li>针对session1 step4执行了commit操作,类比于cow的overwrite,覆盖原文件</li> <li>针对session2 step5执行了select操作,由于origin data已被session1 step4覆盖，此时读取的数据内容balance=9</li> </ul> <h5 id="rr隔离级别下的mvcc">RR隔离级别下的MVCC</h5> <p>示例1: | step | Tx | Session1 | Tx | Session2 | | :— | —- | :———————————————————– | —- | :———————————- | | 1 | tx1 | begin; | tx2 | begin; | | 2 | tx1 | update account set balance = balance-1,update_time = now() where balance&gt;0 and id = 1; | tx2 | | | 3 | tx1 | | tx2 | select id,balance,username from account where id = 1; | | 4 | tx1 | commit; | tx2 | | | 5 | | | tx2 | select id,balance,username from account where id =1; | | 6 | | | tx2 | commit; |</p> <p>对于RC,session2 两次读的数据输出如下:</p> <ul> <li> <p>step3 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">10</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step5 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">10</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> </ul> <p>RR隔离级别要求同一个事务中，对于同一条SQL语句,两次读取的内容需要一致而不论tx1是否提交，这点也是RR与RC读取数据方面一个最大的区别</p> <p>下面来看一个稍微复杂一点的例子</p> <p>示例2:</p> <table> <thead> <tr> <th style="text-align: left">step</th> <th style="text-align: left">Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th style="text-align: left">Session2</th> <th style="text-align: left">Tx</th> <th style="text-align: left">Session3</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td style="text-align: left">tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td style="text-align: left">begin;</td> <td style="text-align: left">tx3</td> <td style="text-align: left">begin;</td> </tr> <tr> <td style="text-align: left">2</td> <td style="text-align: left">tx1</td> <td style="text-align: left">update account set balance = balance-1,update_time = now() where balance&gt;0 and id = 1;</td> <td> </td> <td style="text-align: left"> </td> <td style="text-align: left">tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> </tr> <tr> <td style="text-align: left">3</td> <td style="text-align: left">tx1</td> <td style="text-align: left"> </td> <td> </td> <td style="text-align: left"> </td> <td style="text-align: left">tx3</td> <td style="text-align: left">update account set balance = balance-1,update_time = now() where balance&gt;0 and id = 1; – maybee waiting unitl session1 tx1 commit</td> </tr> <tr> <td style="text-align: left">4</td> <td style="text-align: left">tx1</td> <td style="text-align: left">commit;</td> <td> </td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left">– tx3 will be successful when waiting not timeout</td> </tr> <tr> <td style="text-align: left">5</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> <td style="text-align: left">tx3</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> </tr> <tr> <td style="text-align: left">6</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td> </td> <td style="text-align: left"> </td> <td style="text-align: left">tx3</td> <td style="text-align: left">commit;</td> </tr> <tr> <td style="text-align: left">7</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">select * from account where id =1;</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> </tr> <tr> <td style="text-align: left">8</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">commit;</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> </tr> </tbody> </table> <p>session 1,2,3按顺序开启</p> <ul> <li> <p>step2 session3 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>      <span class="mi">10</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step5 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>       <span class="mi">9</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step5 session3 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>       <span class="mi">8</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> <li> <p>step7 session2 输出:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">balance</span> <span class="o">|</span> <span class="n">username</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span>       <span class="mi">9</span> <span class="o">|</span> <span class="n">alice</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------+----------+</span>
</pre></td></tr></tbody></table></code></pre></div> </div> </li> </ul> <p>对比上述结果可以发现:</p> <ul> <li>session2 tx2在tx1提交后/session3 tx3提交前开始读取数据</li> <li>session3 tx3则是在tx1提交更新前开始读取数据</li> </ul> <p>结果是session2 tx2读取到了session1 tx1的数据,并未读取到tx3更新后的数据(因为tx3未提交),网络上大部分说法是可重复读在事务开始的时候读取的内容就不会变(依据是递增的事物版本号)，私以为这个不是特别准确(至少在我当前实验的5.7.36场景不是特别准确,老的版本未经验证),细想下，session2场景，事务都还没开始读取数据，单纯依据事物版本号规则限定了读取的数据范围，某种程度上过于武断</p> <h4 id="read-view">Read View</h4> <p>Read View就是事务进行快照读操作的时候生成的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID,主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据</p> <p>Read View遵循的可见性算法可以大致如下:</p> <table> <thead> <tr> <th style="text-align: left">视图</th> <th>操作</th> <th>可见性</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">当前Read View</td> <td>当前事务提交的修改</td> <td>是</td> </tr> <tr> <td style="text-align: left">当前Read View</td> <td>其他事物未提交的修改</td> <td>否</td> </tr> <tr> <td style="text-align: left">当前Read View</td> <td>其他事物提交的修改早于当前Read View创建</td> <td>是</td> </tr> <tr> <td style="text-align: left">当前Read View</td> <td>其他事物提交的修改玩于当前Read View创建</td> <td>否</td> </tr> </tbody> </table> <p>从事物视图的角度去看MVCC的特性，RC、RR不同的隔离级别下Read View创建的时机</p> <ul> <li>RC隔离级别下,每次快照读,均会基于已提交的数据创建一份新的Read View</li> <li>RR隔离级别下,每次快照读,基于事物启动前已经提交的数据创建一份Read View,后续不会在创建新的Read View</li> <li>写操作冲突(RR下的MVCC示例2中的step3 session3 tx3存在写冲突)在默认锁等待不超时的情况下，会强制读取最新已提交的数据(参见前述COW部分写写冲突中的冲突处理示例),从最终数据一致性的角度去看，写写操作是无法兼容的</li> </ul>]]></content><author><name></name></author><category term="mysql"/><category term="blogs"/><category term="mysql"/><category term="innodb"/><category term="mvcc"/><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Innodb Lock相关介绍与实现</title><link href="https://devsong.github.io/blog/2022/08/004-lock/" rel="alternate" type="text/html" title="Innodb Lock相关介绍与实现"/><published>2022-08-20T10:00:04+08:00</published><updated>2022-08-20T10:00:04+08:00</updated><id>https://devsong.github.io/blog/2022/08/004-lock</id><content type="html" xml:base="https://devsong.github.io/blog/2022/08/004-lock/"><![CDATA[<h3 id="innodb-锁">Innodb 锁</h3> <p>通过前面两节事务、MVCC介绍都出现了锁的影子,下面我们来看下Innodb中锁的内容</p> <p>操作系统以及各个编程语言中都存在关于锁相关内容的介绍,锁的算法以及基础的原理是一致的，不同点主要体现在以下几点</p> <table> <thead> <tr> <th> </th> <th style="text-align: left">数据库锁</th> <th style="text-align: left">操作系统/编程语言</th> </tr> </thead> <tbody> <tr> <td>目标对象</td> <td style="text-align: left">事务</td> <td style="text-align: left">线程</td> </tr> <tr> <td>受保护对象</td> <td style="text-align: left">数据库行记录</td> <td style="text-align: left">内存数据结构/临界资源/共享变量</td> </tr> <tr> <td>持续时间</td> <td style="text-align: left">事务生命周期,时间较长</td> <td style="text-align: left">代码块，时间较短</td> </tr> <tr> <td>类型</td> <td style="text-align: left">表锁/行锁/意向锁</td> <td style="text-align: left">读写锁、互斥量</td> </tr> </tbody> </table> <p>通过上表可以直观的看出来数据库锁与操作系统、编程语言中的锁区别，Mysql由C语言开发,运行与各个宿主机操作系统之上，因此在运行中的mysql实例中同时存在上述两种类型的锁，今天的主角是数据库锁</p> <h3 id="mysql中锁的分类">Mysql中锁的分类</h3> <p>按照大的维度进行分类</p> <ul> <li>表锁，锁住整表，通常用于数据的初始化，大批量的数据迁移，一般是离线操作或者业务低峰时期</li> <li>行锁，基于数据行的锁</li> <li>意向锁,一种介于表锁于行锁之间锁类型，下文会介绍</li> </ul> <p>按照读写类型进行分类</p> <ul> <li>读锁/共享锁，亦称之为S锁</li> <li>写锁/排它锁，亦称之为X锁</li> </ul> <p>上述三种类型的锁，每种又有相对应的读锁于写锁,读写锁的兼容可以参见下表</p> <table> <thead> <tr> <th style="text-align: left">操作类型</th> <th style="text-align: left">S</th> <th style="text-align: left">X</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">S</td> <td style="text-align: left">兼容</td> <td style="text-align: left">不兼容</td> </tr> <tr> <td style="text-align: left">X</td> <td style="text-align: left">不兼容</td> <td style="text-align: left">不兼容</td> </tr> </tbody> </table> <p>注意，此处的读写锁兼容不要与上文MVCC章节中介绍的读写操作搞混，表锁以及行锁的读写锁操作类型兼容性均与上表一致,意向锁的兼容类型比较特殊，下文会介绍</p> <p>来看一个表锁的示例</p> <table> <thead> <tr> <th style="text-align: left">step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th style="text-align: left">Session2</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td style="text-align: left">begin;</td> </tr> <tr> <td style="text-align: left">2</td> <td>tx1</td> <td style="text-align: left">lock tables account read;</td> <td>tx2</td> <td style="text-align: left">select id,balance,username from account where id = 1;</td> </tr> <tr> <td style="text-align: left">3</td> <td>tx1</td> <td style="text-align: left">select * from account where id =1;</td> <td>tx2</td> <td style="text-align: left">insert into account values(NULL,10,’footer’,now(),now());</td> </tr> <tr> <td style="text-align: left">4</td> <td>tx1</td> <td style="text-align: left">insert into account values(NULL,10,’foobar’,now(),now());</td> <td>tx2</td> <td style="text-align: left">– waiting until tx1 unlock tables;</td> </tr> <tr> <td style="text-align: left">5</td> <td>tx1</td> <td style="text-align: left">ERROR 1099 (HY000): Table ‘account’ was locked with a READ lock and can’t be updated</td> <td>tx2</td> <td style="text-align: left"> </td> </tr> <tr> <td style="text-align: left">6</td> <td>tx1</td> <td style="text-align: left">unlock tables;</td> <td>tx2</td> <td style="text-align: left">commit;</td> </tr> </tbody> </table> <p>通过上述示例可以知道</p> <ul> <li>表锁在S锁的模式下，其他事务无法修改，只能进行读取，无法进行任何写入操作，参见上述读写锁的兼容性描述</li> <li>表锁在S锁的模式下，当前事务亦不能进行数据的修改操作，参见上述step5 session1的错误输出</li> </ul> <p>表锁的X锁模式与上述类似,不同的是在加X锁的情况下，其他的事务读操作会被阻塞(X锁于其他任何类型的锁都不兼容)，此处不在放具体的示例，感兴趣的同学可以执行下述的语句</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">lock</span> <span class="n">tables</span> <span class="n">account</span> <span class="k">write</span><span class="p">;</span>
<span class="p">...</span> <span class="k">do</span> <span class="n">something</span> <span class="k">for</span> <span class="k">write</span> <span class="k">operation</span>
<span class="n">unlock</span> <span class="n">tables</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h4 id="意向锁">意向锁</h4> <p>上文提到意向锁是一种介于行锁于表锁之间的锁定，我们知道innodb底层是基于数据页(16kb)的,一张表物理上实际由N多个16KB的数据页构成，带来的一个问题就是锁定上粗细粒度的问题，表锁过于粗，行锁某写场景下过于细，意向锁的出现就是为了支持在不同粒度上进行加锁，意向锁也分为读/写锁，通常用IS/IX指代,</p> <p>举两个例子</p> <ul> <li>若需要对记录上X锁,则需要对记录所属的库/表/页/记录先上意向锁IX,若中间有任何一个环节造成IX锁等待，那么该环节需要等待更粗粒度的锁完成后，释放相关的意向锁资源方可继续进行</li> <li>若需要对记录上S锁,则需要对记录所属的库/表/页/记录先上意向锁IS,若中间有任何一个环节造成IS锁等待，那么该环节需要等待更粗粒度的锁完成后，释放相关的意向锁资源方可继续进行</li> </ul> <p>需要注意的是，innodb支持的意向锁是表级别的(参见官方文档:<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">mysql锁</a>)，意向锁与其他类型锁之间的兼容下可参见下表</p> <table> <thead> <tr> <th style="text-align: left">操作类型</th> <th>IS</th> <th>IX</th> <th style="text-align: left">S</th> <th style="text-align: left">X</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">IS</td> <td>兼容</td> <td>兼容</td> <td style="text-align: left">兼容</td> <td style="text-align: left">不兼容</td> </tr> <tr> <td style="text-align: left">IX</td> <td>兼容</td> <td>兼容</td> <td style="text-align: left">不兼容</td> <td style="text-align: left">不兼容</td> </tr> <tr> <td style="text-align: left">S</td> <td>兼容</td> <td>不兼容</td> <td style="text-align: left">兼容</td> <td style="text-align: left">不兼容</td> </tr> <tr> <td style="text-align: left">X</td> <td>不兼容</td> <td>不兼容</td> <td style="text-align: left">不兼容</td> <td style="text-align: left">不兼容</td> </tr> </tbody> </table> <p>可以看到X锁仍然是不与其他任何类型的锁兼容</p> <h3 id="行锁">行锁</h3> <p>Innodb 支持三种类型的行锁</p> <ul> <li>Record锁,最简单的基于锁定行</li> <li>Gap锁,锁定区间</li> <li>Next-Key锁，锁定区间，包括行记录本身</li> </ul> <p>下述建表语句数据用于演示行锁的几种case</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`t`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`c`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`d`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`c`</span> <span class="p">(</span><span class="nv">`c`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">t</span> <span class="k">values</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="mi">40</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">40</span><span class="p">),(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),(</span><span class="mi">60</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">60</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li>Record锁是使用的比较多也是最简单的一种行锁,诸如下述语句使用的就是行锁</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>上述SQL会基于id=10的行主键生成行锁数据</p> <ul> <li>GAP锁定</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span><span class="mi">10</span> <span class="k">and</span> <span class="n">id</span><span class="o">&lt;</span><span class="mi">15</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>看下下述示例:</p> <table> <thead> <tr> <th style="text-align: left">step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th style="text-align: left">Session2</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td style="text-align: left">begin;</td> </tr> <tr> <td style="text-align: left">2</td> <td>tx1</td> <td style="text-align: left">select * from t where id &gt;10 and id&lt;15 for update;</td> <td>tx2</td> <td style="text-align: left">insert into t values(8,8,8); – Query OK, 1 row affected (0.00 sec)</td> </tr> <tr> <td style="text-align: left">3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">insert into t values(21,21,21); – Query OK, 1 row affected (0.00 sec)</td> </tr> <tr> <td style="text-align: left">4</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">insert into t values(18,18,18); – waiting until tx1 commit or rollback</td> </tr> <tr> <td style="text-align: left">5</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td style="text-align: left">commit;</td> </tr> </tbody> </table> <p>step 2 tx1 session1 执行<code class="language-plaintext highlighter-rouge">select * from t where id &gt;10 and id&lt;15 for update;</code>范围查询，mysql表中数据想为0，10，20，30，40，50，60，针对此范围查询，生成的GAP锁定区间为(10,20),前后均为开区间</p> <ul> <li>Next-Key 锁定</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">where</span> <span class="k">c</span> <span class="o">&gt;</span><span class="mi">10</span> <span class="k">and</span> <span class="k">c</span><span class="o">&lt;=</span><span class="mi">20</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>如下辅助索引示例</p> <table> <thead> <tr> <th style="text-align: left">step</th> <th>Tx</th> <th style="text-align: left">Session1</th> <th>Tx</th> <th style="text-align: left">Session2</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td>tx1</td> <td style="text-align: left">begin;</td> <td>tx2</td> <td style="text-align: left">begin;</td> </tr> <tr> <td style="text-align: left">2</td> <td>tx1</td> <td style="text-align: left">select * from t where id &gt;10 and id&lt;=20 for update;</td> <td>tx2</td> <td style="text-align: left">insert into t values(8,8,8); – Query OK, 1 row affected (0.00 sec)</td> </tr> <tr> <td style="text-align: left">3</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">insert into t values(21,21,21); –waiting until tx1 commit or rollback</td> </tr> <tr> <td style="text-align: left">4</td> <td>tx1</td> <td style="text-align: left"> </td> <td>tx2</td> <td style="text-align: left">insert into t values(31,31,31); – Query OK, 1 row affected (0.00 sec)</td> </tr> <tr> <td style="text-align: left"> </td> <td> </td> <td style="text-align: left"> </td> <td> </td> <td style="text-align: left">update t set d=d+1 where c=30;–waiting until tx1 commit or rollback</td> </tr> <tr> <td style="text-align: left">5</td> <td>tx1</td> <td style="text-align: left">commit;</td> <td>tx2</td> <td style="text-align: left">commit;</td> </tr> </tbody> </table> <p>step2 tx1 session1 执行<code class="language-plaintext highlighter-rouge">select * from t where id &gt;10 and id&lt;=20 for update;</code> 辅助索引范围查询,针对此查询的锁定区间为辅助索引(10,20],(20,30],session2 中的三个insert语句以及update语句可以验证猜想</p> <h3 id="一点总结">一点总结</h3> <p>实际上，innodb在默认的RR隔离级别下，默认使用next-key锁定，满足一定条件会退化为行锁或者gap锁定，行锁住要针对主键/唯一索引，gap锁住要针对范围查询，上述两个示例是两个最简单的示例，实际上的锁定规则远比此复杂,索引唯一性、查找类型(等值or范围)、全表扫描、事务隔离级别等均有一定程度的关系，详细的示例可参见下述链接 <a href="http://www.heartthinkdo.com/?p=3741#22">http://www.heartthinkdo.com/?p=3741#22</a></p> <p>三种行锁的规则为：</p> <p>（1）Next-Key是默认锁。左开右闭,理解：右闭是行锁（一行记录），左开-右开是间隙锁，所以某种程度上Next-KEY=行锁+间隙锁</p> <p>（2）行锁场景</p> <ul> <li>主键、唯一索引上等值查询，对主键B+树上元素。</li> <li>普通索引需要回表（等值&amp;范围）， 主键B+树上满足条件的元素都是行锁。</li> </ul> <p>（2）间隙锁场景，Innodb在RR级别解决幻读就是靠间隙锁实现</p> <ul> <li>主键等值查询，只有在未找到元素时候，需要对向右第一个元素加间隙锁。</li> <li>主键范围查询时，无论是否有结果，需要向右第一个元素加Next-Key。</li> <li>二级索引等值查询时，无论是否命中结果，需要对向右第一个元素加间隙锁。</li> </ul>]]></content><author><name></name></author><category term="mysql"/><category term="blogs"/><category term="mysql"/><category term="innodb"/><category term="lock"/><summary type="html"><![CDATA[Innodb 锁 通过前面两节事务、MVCC介绍都出现了锁的影子,下面我们来看下Innodb中锁的内容]]></summary></entry><entry><title type="html">Java String hashCode分析系列</title><link href="https://devsong.github.io/blog/2022/03/001-%E7%9B%AE%E5%BD%95/" rel="alternate" type="text/html" title="Java String hashCode分析系列"/><published>2022-03-30T10:31:04+08:00</published><updated>2022-03-30T10:31:04+08:00</updated><id>https://devsong.github.io/blog/2022/03/001-%E7%9B%AE%E5%BD%95</id><content type="html" xml:base="https://devsong.github.io/blog/2022/03/001-%E7%9B%AE%E5%BD%95/"><![CDATA[<h3 id="java-string-hash探讨">Java String Hash探讨</h3> <ul> <li> <p><a href="/blog/2022/03/002-Object以及HashCode简介/">01.Object以及HashCode简介</a></p> </li> <li> <p><a href="/blog/2022/03/003-常用类的hashCode与equals/">02.常用的hashCode与equals</a></p> </li> <li> <p><a href="/blog/2022/03/004-散列与布隆过滤器">03.散列与布隆过滤器</a></p> </li> </ul>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="index"/><summary type="html"><![CDATA[Java String Hash探讨]]></summary></entry><entry><title type="html">Object以及HashCode简介</title><link href="https://devsong.github.io/blog/2022/03/002-Object%E4%BB%A5%E5%8F%8AHashCode%E7%AE%80%E4%BB%8B/" rel="alternate" type="text/html" title="Object以及HashCode简介"/><published>2022-03-30T10:31:04+08:00</published><updated>2022-03-30T10:31:04+08:00</updated><id>https://devsong.github.io/blog/2022/03/002-Object%E4%BB%A5%E5%8F%8AHashCode%E7%AE%80%E4%BB%8B</id><content type="html" xml:base="https://devsong.github.io/blog/2022/03/002-Object%E4%BB%A5%E5%8F%8AHashCode%E7%AE%80%E4%BB%8B/"><![CDATA[<h2 id="hash简介以及java-hashcode的用途">Hash简介以及Java HashCode的用途</h2> <p>Hash俗称散列,在不同的语言中有不同的别名,学过数据结构的同学对此应该不陌生,最简单的hash算法取模如下</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashAlg</span><span class="o">(</span><span class="kt">int</span> <span class="n">origin</span><span class="o">){</span>
    <span class="k">return</span> <span class="n">origin</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>将输入的参数对一个特定的数取模,得到一个<code class="language-plaintext highlighter-rouge">特征值</code>，得到的那个值即为通常意义上的散列值(hashCode), 相较于传统的通过key查找数据，散列表/hash表查找数据的方式通常需要将key进行一定的运算，得到hash值,然后用hash值进行定位查找数据, 通常意义上的散列算法的时间复杂度为O(1),这也是为什么散列如此常见与流行的一个原因</p> <p>众所周知，Java的<code class="language-plaintext highlighter-rouge">Object</code>类是所有的类型的基类,Object中的方法列表如下:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre> <span class="kd">public</span> <span class="nf">Object</span><span class="o">()</span> <span class="o">{}</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getClass</span><span class="o">();</span>

 <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">();</span>

 <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="kd">protected</span> <span class="kd">native</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">CloneNotSupportedException</span><span class="o">;</span>

 <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"@"</span> <span class="o">+</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toHexString</span><span class="o">(</span><span class="n">hashCode</span><span class="o">());</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">notify</span><span class="o">();</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">notifyAll</span><span class="o">();</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">wait</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="n">wait</span><span class="o">(</span><span class="mi">0L</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeoutMillis</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">;</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeoutMillis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nanos</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">timeoutMillis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"timeoutMillis value is negative"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nanos</span> <span class="o">&gt;</span> <span class="mi">999999</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"nanosecond timeout value out of range"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">timeoutMillis</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="n">wait</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span> <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到，里面的大部分方法均为native方法,非native的方法除去equals方法，均为直接或者间接的调用了native的方法,默认的<code class="language-plaintext highlighter-rouge">toString</code>方法的实现也用到了hashCode方法, 本章的主角咋们来说说<code class="language-plaintext highlighter-rouge">equals</code>与<code class="language-plaintext highlighter-rouge">hashCode</code>这两个方法</p> <h3 id="一个老生常谈的问题">一个老生常谈的问题</h3> <p>大家在初学Java这门编程语言的时候,经常被问到的一个问题就是<code class="language-plaintext highlighter-rouge">equals</code>与<code class="language-plaintext highlighter-rouge">==</code>在比较对象时候有什么异同,String对象的<code class="language-plaintext highlighter-rouge">equals</code>与<code class="language-plaintext highlighter-rouge">==</code>之间的区别, 进一步的知识点可能会被问到<code class="language-plaintext highlighter-rouge">Byte</code>这类冷门点的话题,诸如以下代码</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">abc</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">abcObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">abc</span> <span class="o">==</span> <span class="s">"abc"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">abc</span> <span class="o">==</span> <span class="n">abcObj</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>众所周知，Java并不支持操作符重载,关于<code class="language-plaintext highlighter-rouge">==</code>比较的永远是两个对象的地址,想要实现C++中的操作符重载的效果，需要自己编码(编写方法)实现对应的功能,<code class="language-plaintext highlighter-rouge">equals</code>方法为Object的方法, 默认的<code class="language-plaintext highlighter-rouge">equals</code>方法比较的是两个对象的内存地址,<code class="language-plaintext highlighter-rouge">equals</code>方法可以被子类重写,对应的hashCode也可以被重写,事实上这俩要重写的话通常是需要成对进行重写</p> <p>那么，hashCode与内存地址有什么关系,事实上在现今JDK版本(JDK8往上)这俩并没有实质性的关系，可以认为是两个完全不同的东西，</p> <p><img src="/assets/img/java/string/address.jpg" width="760" height="500" alt="address"/></p> <ul> <li> <p>内存地址在程序的进程地址空间中是唯一的,内存由系统按需分配，故内存地址的值通常是不可预知的</p> </li> <li> <p>默认的<code class="language-plaintext highlighter-rouge">hashCode</code>实现由JVM底层的Native方法实现,感兴趣的同学可以参见OpenJdk中关于hashCode实现的部分,对应的代码仓库如下 <a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdk</a></p> </li> </ul> <p>对应的实现代码如下(可能需要切换分支,下述代码在jdk11的系列分支是存在的，文件名为synchronizer.cpp):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">intptr_t</span> <span class="nf">get_next_hash</span><span class="p">(</span><span class="n">Thread</span> <span class="o">*</span> <span class="n">Self</span><span class="p">,</span> <span class="n">oop</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">intptr_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This form uses global Park-Miller RNG.</span>
    <span class="c1">// On MP system we'll have lots of RW access to a global, so the</span>
    <span class="c1">// mechanism induces lots of coherency traffic.</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">os</span><span class="o">::</span><span class="n">random</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This variation has the property of being stable (idempotent)</span>
    <span class="c1">// between STW operations.  This can be useful in some of the 1-0</span>
    <span class="c1">// synchronization schemes.</span>
    <span class="kt">intptr_t</span> <span class="n">addrBits</span> <span class="o">=</span> <span class="n">cast_from_oop</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">addrBits</span> <span class="o">^</span> <span class="p">(</span><span class="n">addrBits</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">^</span> <span class="n">GVars</span><span class="p">.</span><span class="n">stwRandom</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// for sensitivity testing</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="o">++</span><span class="n">GVars</span><span class="p">.</span><span class="n">hcSequence</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">cast_from_oop</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Marsaglia's xor-shift scheme with thread-specific state</span>
    <span class="c1">// This is probably the best overall implementation -- we'll</span>
    <span class="c1">// likely make this the default in future releases.</span>
    <span class="kt">unsigned</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateX</span><span class="p">;</span>
    <span class="n">t</span> <span class="o">^=</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
    <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateX</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateY</span><span class="p">;</span>
    <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateY</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateZ</span><span class="p">;</span>
    <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateZ</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">^</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">19</span><span class="p">))</span> <span class="o">^</span> <span class="p">(</span><span class="n">t</span> <span class="o">^</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
    <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">value</span> <span class="o">&amp;=</span> <span class="n">markOopDesc</span><span class="o">::</span><span class="n">hash_mask</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">value</span> <span class="o">=</span> <span class="mh">0xBAD</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">markOopDesc</span><span class="o">::</span><span class="n">no_hash</span><span class="p">,</span> <span class="s">"invariant"</span><span class="p">);</span>
  <span class="n">TEVENT</span><span class="p">(</span><span class="n">hashCode</span><span class="o">:</span> <span class="n">GENERATE</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到,native的实现总共有6种,从上往下的类型编号分别为0-5,依次排序,</p> <ul> <li>0:调用os::random() 生成hashCode，亦即使用一个随机值做hashCode</li> <li>1:内存地址做移位操作,然后与steRandom(随机数)做异或操作</li> <li>2:固定值1</li> <li>3:自增序列</li> <li>4:使用对象的内存地址</li> <li>5:当前线程中的四个数字(实际上是一个随机数+三个确定值)运用xorshift随机数算法得到的一个随机数</li> </ul> <p>默认的实现为5,亦即上述列表中的最后一个,从注释中也可以看到此算法作者的本意在将来的版本中会成为默认的hashCode实现,实际上由于这部分代码提交历史比较久了，此实现现在已经成为了默认的实现,对于上述规则中1和4，hashCode的计算确实与内存地址有一定的关系,早期版本的JDK实现是否采用此实现暂未考究,也不在系列讨论的范畴中</p> <p>thread.cpp中关于线程threadState x y z w的四个值的初始化如下:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>  <span class="c1">// thread-specific hashCode stream generator state - Marsaglia shift-xor form</span>
  <span class="n">_hashStateX</span> <span class="o">=</span> <span class="nl">os:</span><span class="o">:</span><span class="n">random</span><span class="o">();</span>
  <span class="n">_hashStateY</span> <span class="o">=</span> <span class="mi">842502087</span><span class="o">;</span>
  <span class="n">_hashStateZ</span> <span class="o">=</span> <span class="mh">0x8767</span><span class="o">;</span>    <span class="c1">// (int)(3579807591LL &amp; 0xffff) ;</span>
  <span class="n">_hashStateW</span> <span class="o">=</span> <span class="mi">273326509</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到上述值除开x外,y z w三个值均为固定值(通常又称之为MagicNumber),下述代码为测试代码，可以测试默认的hashCode实现</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">mainHashObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">info</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"toString:%s,hex:%s,hashCode:%s"</span><span class="o">,</span> <span class="n">mainHashObj</span><span class="o">,</span> 	<span class="nc">Integer</span><span class="o">.</span><span class="na">toHexString</span><span class="o">(</span><span class="n">mainHashObj</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()),</span> <span class="n">mainHashObj</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">info</span><span class="o">);</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>注意，编译运行上述代码需要加上jvm参数 <code class="language-plaintext highlighter-rouge">-XX:+UnlockExperimentalVMOptions -XX:hashCode=2</code> 参数,不然会使用jdk默认的hashCode算法实现,下面是这俩参数的解释:</p> <ul> <li>UnlockExperimentalVMOptions 解锁专家模式</li> <li>hashCode=2 配置那种hash算法为默认的,此处的2即为上述列表中的0-5，具体含义参见上述解释，不在赘述</li> </ul> <p>可以手动修改hashCode的值,重复运行上述代码，观察默认的hashCode值的变化情况从而验证</p>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="java"/><category term="string"/><category term="hashCode"/><summary type="html"><![CDATA[Hash简介以及Java HashCode的用途]]></summary></entry><entry><title type="html">常用类的hashCode与equals方法</title><link href="https://devsong.github.io/blog/2022/03/003-%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84hashCode%E4%B8%8Eequals/" rel="alternate" type="text/html" title="常用类的hashCode与equals方法"/><published>2022-03-30T10:31:04+08:00</published><updated>2022-03-30T10:31:04+08:00</updated><id>https://devsong.github.io/blog/2022/03/003-%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84hashCode%E4%B8%8Eequals</id><content type="html" xml:base="https://devsong.github.io/blog/2022/03/003-%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84hashCode%E4%B8%8Eequals/"><![CDATA[<h3 id="常见类型的hashcode算法实现">常见类型的hashCode算法实现</h3> <p>第一章节我们了解到,java的Object类有hashCode，并且也介绍了默认的5种hashCode实现方式，下面我们来看看java中关于常见的对象hashCode实现(基本类型可以参见对应的包装类型)</p> <ul> <li>Boolean: true/false分别返回1231/1237这俩素数</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Boolean</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">?</span> <span class="mi">1231</span> <span class="o">:</span> <span class="mi">1237</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li>Byte/Short/Integer:</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Byte</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">byte</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">value</span><span class="o">;</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li>Float:</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">float</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">floatToIntBits</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">floatToIntBits</span><span class="o">(</span><span class="kt">float</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isNaN</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">floatToRawIntBits</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mh">0x7fc00000</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">floatToRawIntBits</span><span class="o">(</span><span class="kt">float</span> <span class="n">value</span><span class="o">);</span>

</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li>Double:</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Double</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">double</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">doubleToLongBits</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">bits</span> <span class="o">^</span> <span class="o">(</span><span class="n">bits</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">doubleToLongBits</span><span class="o">(</span><span class="kt">double</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isNaN</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">doubleToRawLongBits</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mh">0x7ff8000000000000</span><span class="no">L</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">long</span> <span class="nf">doubleToRawLongBits</span><span class="o">(</span><span class="kt">double</span> <span class="n">value</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li>Long:</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Long</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
<span class="o">}</span>


<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">value</span> <span class="o">^</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">));</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li>String</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="c1">//  s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="n">h</span> <span class="o">=</span> <span class="n">isLatin1</span><span class="o">()</span> <span class="o">?</span> <span class="nc">StringLatin1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                <span class="o">:</span> <span class="nc">StringUTF16</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// StringLatin1 的实现</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">v</span> <span class="o">:</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="o">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// StringUTF16 的实现</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">getChar</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到，针对于byte/short/integer，hashcode即为值本身,float/double/long的计算稍微复杂一点,基本都是基于字节数组做一些运算,String hashCode计算稍显复杂一点，字节数组的值加上一个素数的多项式公式的幂次方构成。</p> <p>java的hashCode返回的是一个int值，int的范围是-21亿到21亿之间，hash算法一般需要考虑几个点</p> <ul> <li>速度尽可能的快.</li> <li>尽量产生少的冲突,冲突过多的话，会导致很多数据经过hash计算后，hashcode一致，从而影响hash的查找效率</li> </ul> <p>基于上述两点,通常情况下对于多项式幂的底数的选择是一件比较困难的事情，此处选择31基于上述两点做一些取舍,effective java也有相关提及,任何数乘以31可以被优化为 <code class="language-plaintext highlighter-rouge">31*h = (32-1)*h = h&lt;&lt;5 -h</code>,可以把乘法运算转换为移位和加法运算,我们知道,对于计算机而言,移位运算与加法运算的时间复杂度基本是同级的,乘法与除法相较于上述两类运算稍慢些,其实对应的可选素数还有17 (<code class="language-plaintext highlighter-rouge">17*h = (16+1)*h = h&lt;&lt;4 + h&gt;)</code>,单纯从数学的角度来讲，选择31可能并不是最合适的,计算机是一门理论与工程实践相结合的学科，这类优化提升对于cpu的指令运算速度有提升,下述代码是一个生成测试数据的示例代码,选了两组数做对比</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">com.google.common.collect.Lists</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.collect.Maps</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.AllArgsConstructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.Data</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.NoArgsConstructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.lang3.RandomStringUtils</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Collectors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Stream</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringHashDemo</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">BASIC_NUMBERS</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7877</span><span class="o">,</span><span class="mi">8689</span><span class="o">,</span> <span class="mi">9421</span><span class="o">,</span> <span class="mi">200329</span><span class="o">,</span> <span class="mi">401113</span><span class="o">,</span> <span class="mi">499691</span><span class="o">,</span> <span class="mi">901177</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">CNT</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">GROUP</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calcHashCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">prime</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">prime</span> <span class="o">+</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">buildMap</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">prime</span> <span class="o">:</span> <span class="no">BASIC_NUMBERS</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buildData</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">prime</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">outPutFile</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
        <span class="n">outPutFile2</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="nf">buildMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Maps</span><span class="o">.</span><span class="na">newTreeMap</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">groupCount</span> <span class="o">=</span> <span class="no">CNT</span> <span class="o">/</span> <span class="mi">20</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">GROUP</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">groupCount</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="nc">RandomStringUtils</span><span class="o">.</span><span class="na">randomAlphabetic</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">result</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StrValObject</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">buildData</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">mapData</span><span class="o">,</span> <span class="kt">int</span> <span class="n">prime</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">mapData</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">StrValObject</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">calcHashCode</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">prime</span><span class="o">);</span>
            <span class="nc">InnerStrValObj</span> <span class="n">innerStrValObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InnerStrValObj</span><span class="o">(</span><span class="n">prime</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
            <span class="n">value</span><span class="o">.</span><span class="na">getList</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">innerStrValObj</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">outPutFile</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"/tmp/hash_code.csv"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="n">fw</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">BASIC_NUMBERS</span><span class="o">).</span><span class="na">boxed</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">header</span> <span class="o">=</span> <span class="s">"str,"</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="s">"hash_code_"</span> <span class="o">+</span> <span class="n">i</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">header</span><span class="o">);</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">InnerStrValObj</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">getList</span><span class="o">();</span>
            <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">row</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">obj</span> <span class="o">-&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">+</span> <span class="s">""</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">outPutFile2</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BufferedWriter</span><span class="o">&gt;</span> <span class="n">writers</span> <span class="o">=</span> <span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">prime</span> <span class="o">:</span> <span class="no">BASIC_NUMBERS</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"/tmp/hash_code/hash_code"</span> <span class="o">+</span> <span class="n">prime</span> <span class="o">+</span> <span class="s">".csv"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="n">fw</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">header</span> <span class="o">=</span> <span class="s">"str,hash_code_"</span> <span class="o">+</span> <span class="n">prime</span><span class="o">;</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">header</span><span class="o">);</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>

            <span class="n">writers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">bw</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">StrValObject</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">InnerStrValObj</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">getList</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">InnerStrValObj</span> <span class="n">innerStrValObj</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">row</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s,%s"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">innerStrValObj</span><span class="o">.</span><span class="na">getHash</span><span class="o">());</span>
                <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="n">writers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">:</span> <span class="n">writers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Data</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">class</span> <span class="nc">StrValObject</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">InnerStrValObj</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Data</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">class</span> <span class="nc">InnerStrValObj</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">InnerStrValObj</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">prime</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">InnerStrValObj</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prime</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="na">getPrime</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">prime</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">.</span><span class="na">getPrime</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>合并csv的python代码</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">os</span> <span class="k">as</span> <span class="n">os</span>

<span class="n">BASE_TMP_DIE</span> <span class="o">=</span> <span class="s">'/tmp/hash_code/'</span>

<span class="n">writer</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">ExcelWriter</span><span class="p">(</span><span class="s">'~/Desktop/hash_code_multiple_large_number.xlsx'</span><span class="p">)</span>

<span class="n">listdir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="n">BASE_TMP_DIE</span><span class="p">)</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">isfile</span><span class="p">(</span><span class="n">BASE_TMP_DIE</span> <span class="o">+</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">sheetname</span> <span class="o">=</span> <span class="n">filename</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'.'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">csvfile</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">BASE_TMP_DIE</span> <span class="o">+</span> <span class="n">filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf8"</span><span class="p">)</span>
        <span class="n">csvfile</span><span class="p">.</span><span class="nf">to_excel</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="n">sheetname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">writer</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

</pre></td></tr></tbody></table></code></pre></div></div> <p>生成的excel数据做了两套散点图,参考如下:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">BASIC_NUMBERS</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">31</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span><span class="mi">41</span><span class="o">,</span><span class="mi">48</span><span class="o">,</span><span class="mi">61</span><span class="o">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/java/string/hash_code_little.jpg" width="760" height="500" alt="hash_code_little.jpg"/></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">BASIC_NUMBERS</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7877</span><span class="o">,</span><span class="mi">8689</span><span class="o">,</span> <span class="mi">9421</span><span class="o">,</span> <span class="mi">200329</span><span class="o">,</span> <span class="mi">401113</span><span class="o">,</span> <span class="mi">499691</span><span class="o">,</span> <span class="mi">901177</span><span class="o">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/java/string/hash_code_big.jpg" width="760" height="500" alt="hash_code_big.jpg"/></p> <p>程序的整体逻辑生成10000个左右的随机数,数据一共20组，每组数据500个，重复数据会被过滤，整体样本数据大概9000+， 从第一张图可以看到基本每个数据都有一个比较平缓的线条区域,由于生成的hashcode区间比较广,图像的纵坐标的值的跨度范围比较大,平的那一部分不代表这部分数据相等，只是说明这部分数据的区间范围相对而言比较集中，集中的意思预示着这部分数据产生冲突的概率比较大,样本生成的数据是一样的，采样控制变量法,修改运算的基数，从而可以比较用哪个素数来生成hashCode比较合适</p> <p>第二张图采用的是几个比较大的素数，可以看到生成的图像近似于一条直线,相较于第一张而言产生的冲突概率较小， hashCode值分布教均匀</p> <h2 id="为什么需要在重写equals的同时重写hashcode方法">为什么需要在重写equals的同时重写hashCode方法</h2> <p>从上一章节中我们知道equals与hashCode是object类的两个方法,在我们进行编码的时候, 如果判断两个对象相等,我们通常都会重写equals方法,常用的IDE都会检测到我们重写了equals方法的时候, 通常都会建议我们重些hashCode方法,我们看下述代码,不重写hashCode的情形:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="nd">@Data</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ObjectWithOutHashCode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">ObjectWithOutHashCode</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ObjectWithOutHashCode</span> <span class="n">o</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ObjectWithOutHashCode</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectWithOutHashCode</span> <span class="n">obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectWithOutHashCode</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"test"</span><span class="o">);</span>
        <span class="nc">ObjectWithOutHashCode</span> <span class="n">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectWithOutHashCode</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"test"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">obj1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">obj2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"obj1 equals obj2:"</span> <span class="o">+</span> <span class="n">obj1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">obj2</span><span class="o">));</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ObjectWithOutHashCode</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">obj1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">obj2</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj2</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ObjectWithOutHashCode</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="nc">Sets</span><span class="o">.</span><span class="na">newHashSet</span><span class="o">(</span><span class="n">obj1</span><span class="o">,</span> <span class="n">obj2</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>针对上述代码,输出结果如下:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="mi">356473385</span><span class="o">,</span><span class="mi">2136344592</span>
<span class="n">obj1</span> <span class="n">equals</span> <span class="nl">obj2:</span><span class="kc">true</span>
<span class="mi">1</span>
<span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到没有覆写hashCode方法的对象，默认使用Object类的hashCode方法,两次new出来的对象hashCode不同,针对于<code class="language-plaintext highlighter-rouge">equals</code>方法返回true的情形, 集合接口<code class="language-plaintext highlighter-rouge">ArrayList</code>与<code class="language-plaintext highlighter-rouge">HashSet</code>的行为不太一致,可以参见ArrayList的add方法</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">indexOf</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">indexOfRange</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">indexOfRange</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">es</span> <span class="o">=</span> <span class="n">elementData</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">es</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">es</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到针对对象不为空的情形,判断对象是否相等的方法使用的是<code class="language-plaintext highlighter-rouge">equals</code>，而HashSet的底层是基于<code class="language-plaintext highlighter-rouge">HashMap</code>实现,可以看看<code class="language-plaintext highlighter-rouge">HashSet</code>的add方法实现</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">PRESENT</span><span class="o">)==</span><span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 底层调用的是Map的put方法 </span>

<span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// </span>

<span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
                <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// -1 for 1st</span>
                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key</span>
            <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到上述代码在做add的时候，会先去拿对象的hashCode与底层数组的大小做运算，确定元素位于那个槽,倘若hashCode一样(hash冲突),进一步判断对象的equals方法是否相等,这两步相等则认为两个对象是同一个key，否则便是不同的key值了，这也能解释为什么上述list与set的元素个数不一致的原因</p> <p>从上述代码对比我们可以看出,java的集合框架，涉及到底层需要进行hash计算的尽量同时重写这两个方法(除非你真的确认你的对象永远不会放进集合中，但是从程序的健壮性来考虑,重写后的hashCode与equals方法能使代码健壮性更好)。</p> <p>对应的可以看看重写了hashCoe/equals方法的对象输出:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="nd">@Data</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ObjectWithHashCode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">ObjectWithHashCode</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ObjectWithHashCode</span> <span class="n">o</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ObjectWithHashCode</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectWithHashCode</span> <span class="n">obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectWithHashCode</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"test"</span><span class="o">);</span>
        <span class="nc">ObjectWithHashCode</span> <span class="n">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectWithHashCode</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"test"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"obj1 equals obj2:"</span> <span class="o">+</span> <span class="n">obj1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">obj2</span><span class="o">));</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ObjectWithHashCode</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">obj1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">obj2</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj2</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">ObjectWithHashCode</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="nc">Sets</span><span class="o">.</span><span class="na">newHashSet</span><span class="o">(</span><span class="n">obj1</span><span class="o">,</span> <span class="n">obj2</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>输出:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">obj1</span> <span class="n">equals</span> <span class="nl">obj2:</span><span class="kc">true</span>
<span class="mi">1</span>
<span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>so,为了程序少出bug，还是将equals与hashCode成对重写,Java7新增的Objects方法有相关的hash值计算方式</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="c1">// Objects.hash</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">values</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Arrays.hashCode</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="nc">Object</span> <span class="n">a</span><span class="o">[])</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">element</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">element</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">element</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>可以看到,Arrays中的hashCode素数选择用的也是31</p>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="java"/><category term="string"/><category term="hashCode"/><category term="equals"/><summary type="html"><![CDATA[常见类型的hashCode算法实现]]></summary></entry><entry><title type="html">散列算法与布隆过滤器</title><link href="https://devsong.github.io/blog/2022/03/004-%E6%95%A3%E5%88%97%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="alternate" type="text/html" title="散列算法与布隆过滤器"/><published>2022-03-30T10:31:04+08:00</published><updated>2022-03-30T10:31:04+08:00</updated><id>https://devsong.github.io/blog/2022/03/004-%E6%95%A3%E5%88%97%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8</id><content type="html" xml:base="https://devsong.github.io/blog/2022/03/004-%E6%95%A3%E5%88%97%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"><![CDATA[<h3 id="散列算法与布隆过滤器">散列算法与布隆过滤器</h3> <p>在<a href="/blog/2022/03/002-Object以及HashCode简介/">Java Object以及HashCode简介中提到过Hash算法</a>一文中对散列有一个初步的认识，一句话总结散列算法</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>对于任意输入长度的数据，经过Hash运算，使之能映射到指定的地址空间,后续针对此数据的查找演变为针对此特征值的查找过程
</pre></td></tr></tbody></table></code></pre></div></div> <p>互联网下载文件常用的文件校验码是另一类Hash算法的典型应用,用于验证数据的完整性,来看一下apache tomcat的下载页面</p> <p><img src="/assets/img/java/string/tomcat_download.png" width="760" height="500" alt="tomcat_download.png"/></p> <p>可以看到上述标红的部分即为文件的特征码/散列码/Hash值,可以看到文件后缀为sha512，代表使用sha512算法进行的散列，对应的文件内容为</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>4889f416a2c7548d6a94386496a788c7e611b5250df2ab4bddd7f3fba0e6989751983cc0914d32780b8bfe90da98d6f29024c8d60f69c560b8e8295db396e25a *apache-tomcat-8.5.81-deployer.tar.gz
</pre></td></tr></tbody></table></code></pre></div></div> <p>对应的链接地址<a href="https://downloads.apache.org/tomcat/tomcat-8/v8.5.81/bin/">tomcat 8.5.81</a></p> <p>下面简单介绍下互联网上几种散列算法</p> <ul> <li>MD5 知名的散列算法，输出长度固定为16字节(128bit)，出现时间较早，诞生于上个世纪90年代，由Ron Rivest（RSA公司）提出，使用广泛</li> <li>SHA1 与MD5同时代的算法，输出长度固定为20字节(160bit),由NSA提出</li> <li>SHA2 通常包含SHA224,SHA256,SHA384,SHA512 ,SHA1的升级版，数字代表散列值的输出长度，通常长度越长代表越安全</li> <li>SHA3 包含SHA3-224,SHA3-256,SHA3-384,SHA3-512,SHA的第三版，最新的标准</li> </ul> <p>MD5/SHA1均已被攻破，不在被推荐使用，目前SHA2/SHA3暂被认为是安全的，可以放心使用</p> <p>来看一下生活中的一个示例，下图演示法院在对被告作判决一个简短的示意图</p> <p><img src="/assets/img/java/string/court_example.png" alt="tomcat download" style="zoom:60%;"/></p> <p>假定在对红色小人进行判罚的时候，三名证人基于自己了解的事件过程如实作答，基于此判定做出有罪/无罪判罚，在少数服从多数的情况下，假定认为投票数超过一半，那么法官便认为此人可以被定罪从而进行判罚(实际生活中的判罚过程比这个复杂的多的多)</p> <h3 id="bloom-filter">Bloom Filter</h3> <p>上文介绍道散列算法可以对数据做完整形校验,散列值可以近似看作是数据的签名，它们一一对应，但是通常情况下数据是无限的，而签名是经过散列算法运算得到的固定输出的值，理论上来说他的地址空间有限，有限在理论上意味着有可能两个不一样的数据存在重复的可能，同样的在互联网的世界中，集群(实例数&gt;=2)系统提供服务的可靠性(可用性)通常是远远大于单实例，在系统架构允许的情况下,可以选择增加集群中实例的数量，来达到提升系统可用性这一指标数据</p> <p>Bloom Filter过滤器实质上是一个bit向量或者一个bit数组,通常情况下它长这样:</p> <p><img src="/assets/img/java/string/bloom_slot.png" alt="bloom_filter" style="zoom:150%;"/></p> <p>bit 位为0代表数据不存在,bit 位为1 代表有数据，来看两个简单的数据写入示例:</p> <p><img src="/assets/img/java/string/bloom_geeks.png" alt="bloom_geeks.png" style="zoom:150%;"/></p> <ul> <li>“geeks” 进过<code class="language-plaintext highlighter-rouge">hash1("geeks")</code>/<code class="language-plaintext highlighter-rouge">hash2("geeks")</code>/<code class="language-plaintext highlighter-rouge">hash3("geeks")</code> 运算后，生成三个散列值</li> <li>将上述三个散列值分别与数组做取模运算,填充数组下标的值(将指定下标位置置为1)</li> </ul> <p><img src="/assets/img/java/string/bloom_nerd.png" alt="bloom_nerd.png" style="zoom:150%;"/></p> <p>字符串”nerd”的写入过程同上述”geeks”，此处不在赘述</p> <p>查询阶段，针对”geeks”，按照<code class="language-plaintext highlighter-rouge">hash1("geeks")</code>/<code class="language-plaintext highlighter-rouge">hash2("geeks")</code>/<code class="language-plaintext highlighter-rouge">hash3("geeks")</code> 计算后的值与数组长度做取模运算,三个bit都返回1，我们认为”geeks”在bloom filter中<strong>存在,</strong>针对字符串”foobar”,经过<code class="language-plaintext highlighter-rouge">hash1("geeks")</code>/<code class="language-plaintext highlighter-rouge">hash2("geeks")</code>/<code class="language-plaintext highlighter-rouge">hash3("geeks")</code>运算后，假定返回上图中2/5/7这三个值，我们知道2这个位置为0，因此我们可以认为”foobar”字符串<strong>不存在</strong>bloom filter中，针对上述过程，我们可以发现</p> <ul> <li>Bloom Filter需要多个散列函数参与数据集的散列运算</li> <li>Bloom Filter不支持删除(通常意义上Bloom Filter底层数组数据可提前生成，有支持删除的Bloom Filter变种，大家可自行google之)</li> <li>Bloom Filter的向量/数字索引位只能保存2个值,通常代表两个状态</li> <li>由于散列算法天然的特性(无限数据集-&gt;有限地址空间之间的映射)，散列冲突不可避免,因此Bloom Filter的得出数据的存在是一种<strong>假想</strong>意义上的存在,存在一定的误报率，只不过误报率通常情况下较低</li> <li>Bloom Filter返回的不存在代表数据一定不存在</li> <li>Bloom Filter的大小与输入的数据集长度无关</li> </ul> <p>结合上述四点，可以看到Bloom Filter应用的场景非常适合于下述代码场景</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">res</span><span class="o">){</span>
	<span class="nc">String</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">hashAlg1</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
	<span class="nc">String</span> <span class="n">hash2</span> <span class="o">=</span> <span class="n">hashAlg2</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
	<span class="nc">String</span> <span class="n">hash3</span> <span class="o">=</span> <span class="n">hashAlg3</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
	<span class="k">if</span><span class="o">(</span><span class="nc">BloomFilter</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">hash1</span><span class="o">,</span><span class="n">hash2</span><span class="o">,</span><span class="n">hash3</span><span class="o">)){</span>
		<span class="c1">// res</span>
		<span class="k">return</span> <span class="nf">sendBackResNotExist</span><span class="o">();</span>
	<span class="o">}</span><span class="k">else</span><span class="o">{</span>
		<span class="c1">// more action to confirm res exists in business system</span>
		<span class="k">if</span><span class="o">(</span><span class="n">doMoreActionToConfirm</span><span class="o">(</span><span class="n">res</span><span class="o">)){</span>
			<span class="n">addResToBloomFilter</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
			<span class="k">return</span> <span class="nf">sendBackResExist</span><span class="o">();</span>
		<span class="o">}</span><span class="k">else</span><span class="o">{</span>
			<span class="k">return</span> <span class="nf">sendBackResNotExist</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>Bloom Filter被大量应用于web 搜索引擎/反垃圾邮件过滤/缓存穿透等等应用场景，来看一个web 搜索引擎的示例</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>互联网的web url链接的规模通常情况下都数以亿计,假定一家新型的搜索引擎公司需要用爬虫爬取整个互联网的url内容并进行索引，初步假定要爬取的url的数量为100亿条，对于爬虫程序而言，为了降低无谓的工作量,已经被其他爬虫爬取过的页面内容，在近3天时间内无需再次抓取。
</pre></td></tr></tbody></table></code></pre></div></div> <p>上述需求有三个关键点</p> <ul> <li>数据量级较大(100亿),意味着传统的数据库存储方式已经不再适合</li> <li>数据有效期为3天，三天后，为了保证数据的实时性，需要对已经抓取过的URL链接进行重新的抓取</li> <li>每个URL仅需被抓取一次</li> </ul> <p>针对上述三个场景的需要从如下几个方面入手思考</p> <ul> <li> <p>针对场景1 ，假定Bloom Filter 散列函数为三个,那么需要生成的散列值的个数为<code class="language-plaintext highlighter-rouge">3x100x10^9</code>,占用的存储空间大小为<code class="language-plaintext highlighter-rouge">3x100x10^8/(1024*1024*1024*8)</code>，简约计算<code class="language-plaintext highlighter-rouge">3x10x10^9/(10^9*8)</code>,约等于3.75GB的存储空间</p> </li> <li> <p>针对场景2，Bloom Filter通常基于内存，3.75GB内存对于现今的服务器内存动不动上百G来讲，相当于九牛一毛，单台服务的内存就能存下如此多的数据，而且内存具有易失性的特性，借助于现今的各种缓存服务器，针对场景二也能很容易满足</p> </li> <li> <p>针对场景三，结合上述关于Bloom Filter的介绍以及Bloom Filter的应用场景，不难看出场景三也很容易满足</p> </li> </ul> <h3 id="bloom-filter误判率">Bloom Filter误判率</h3> <p>前文提到Bloom Filter对于已经存在的数据，Bloom Filter得出的结果是可能存在，实际上大家通过上述的介绍可以知道,只要散列冲突的概率越小,数组向量的长度越大,最终bit数组中产生的重复数据越小，亦即产生的误判率越低，以下几个方面可以降低Bloom Filter的误判率</p> <ul> <li>散列冲突的概率可以选择合适的散列函数(算法)来优化数据的散列冲突</li> <li>数组向量的绝对长度越大(空间越大),整个Bloom Filter被填满的速度越慢，产生的误判率亦即越低</li> </ul> <p>实际应用上，散列算法的优化/可选择的散列函数均有一大票论文，而且对于技术的要求通常是比较高的，而数组的向量的绝对长度通常是比较好优化的一个手段/方向，基于业务体量,设计良好的分布式Bloom Filter可以支持横向扩展</p>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="java"/><category term="string"/><category term="hashCode"/><category term="bloomfilter"/><summary type="html"><![CDATA[散列算法与布隆过滤器]]></summary></entry><entry><title type="html">MySQL数据库设计规范</title><link href="https://devsong.github.io/blog/2021/07/001-mysql%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="alternate" type="text/html" title="MySQL数据库设计规范"/><published>2021-07-05T10:31:04+08:00</published><updated>2021-07-05T10:31:04+08:00</updated><id>https://devsong.github.io/blog/2021/07/001-mysql%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83</id><content type="html" xml:base="https://devsong.github.io/blog/2021/07/001-mysql%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"><![CDATA[<h1 id="mysql数据库设计规范">MySQL数据库设计规范</h1> <h4 id="原地址参见httpsgithubcomjly8866archerblobmastersrcdocsmysql_db_design_guidemd">原地址参见<a href="https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md">https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md</a></h4> <h2 id="目录">目录</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>1. 规范背景与目的	

2. 设计规范

2.1 数据库设计	

2.1.1 库名	
2.1.2 表结构	
2.1.3 列数据类型优化	
2.1.4 索引设计	
2.1.5 分库分表、分区表	
2.1.6 字符集	
2.1.7 程序DAO层设计建议	
2.1.8 一个规范的建表语句示例	

2.2 SQL编写	

2.2.1 DML语句	
2.2.2 多表连接	
2.2.3 事务	
2.2.4 排序和分组	
2.2.5 线上禁止使用的SQL语句
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="1-规范背景与目的">1. 规范背景与目的</h2> <p>MySQL数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。</p> <h2 id="2-设计规范">2. 设计规范</h2> <h3 id="21-数据库设计">2.1 数据库设计</h3> <p>以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。</p> <p>对于不满足【高危】和【强制】两个级别的设计，DBA会强制打回要求修改。</p> <h3 id="211-库名">2.1.1 库名</h3> <ol> <li>【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量提现join的关系，如user表和user_login表。</li> <li>【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。</li> <li>【强制】一般分库名称命名格式是<code class="language-plaintext highlighter-rouge">库通配名_编号</code>，编号从0开始递增，比如<code class="language-plaintext highlighter-rouge">wenda_001</code>以时间进行分库的名称格式是“库通配名_时间”</li> <li>【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：<code class="language-plaintext highlighter-rouge">create database db1 default character set utf8;</code>。</li> </ol> <h3 id="212-表结构">2.1.2 表结构</h3> <ol> <li>【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。</li> <li>【强制】表名要求模块名强相关，如师资系统采用”sz”作为前缀，渠道系统采用”qd”作为前缀等。</li> <li>【强制】创建表时必须显式指定字符集为utf8或utf8mb4。</li> <li>【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB/MyISAM/Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB。</li> <li>【强制】建表必须有comment</li> <li>【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint，且为<code class="language-plaintext highlighter-rouge">auto_increment(2)</code>标识表里每一行主体的字段不要设为主键，建议设为其他字段如<code class="language-plaintext highlighter-rouge">user_id</code>，<code class="language-plaintext highlighter-rouge">order_id</code>等，并建立unique key索引（可参考<code class="language-plaintext highlighter-rouge">cdb.teacher</code>表设计）。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降。</li> <li>【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段<code class="language-plaintext highlighter-rouge">create_time</code>和最后更新时间字段<code class="language-plaintext highlighter-rouge">update_time</code>，便于查问题。</li> <li>【建议】表中所有字段必须都是<code class="language-plaintext highlighter-rouge">NOT NULL</code>属性，业务可以根据需要定义<code class="language-plaintext highlighter-rouge">DEFAULT</code>值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</li> <li>【建议】建议对表里的<code class="language-plaintext highlighter-rouge">blob</code>、<code class="language-plaintext highlighter-rouge">text</code>等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select。</li> <li>【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如<code class="language-plaintext highlighter-rouge">user_name</code>属性在<code class="language-plaintext highlighter-rouge">user_account</code>，<code class="language-plaintext highlighter-rouge">user_login_log</code>等表里冗余一份，减少join查询。</li> <li>【强制】中间表用于保留中间结果集，名称必须以<code class="language-plaintext highlighter-rouge">tmp_</code>开头。备份表用于备份或抓取源表快照，名称必须以<code class="language-plaintext highlighter-rouge">bak_</code>开头。中间表和备份表定期清理。</li> <li>【强制】对于超过100W行的大表进行<code class="language-plaintext highlighter-rouge">alter table</code>，必须经过DBA审核，并在业务低峰期执行。因为<code class="language-plaintext highlighter-rouge">alter table</code>会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li> </ol> <h3 id="213-列数据类型优化">2.1.3 列数据类型优化</h3> <ol> <li>【建议】表中的自增列（<code class="language-plaintext highlighter-rouge">auto_increment</code>属性），推荐使用<code class="language-plaintext highlighter-rouge">bigint</code>类型。因为无符号<code class="language-plaintext highlighter-rouge">int</code>存储范围为<code class="language-plaintext highlighter-rouge">-2147483648~2147483647</code>（大约21亿左右），溢出后会导致报错。</li> <li>【建议】业务中选择性很少的状态<code class="language-plaintext highlighter-rouge">status</code>、类型<code class="language-plaintext highlighter-rouge">type</code>等字段推荐使用<code class="language-plaintext highlighter-rouge">tinytint</code>或者<code class="language-plaintext highlighter-rouge">smallint</code>类型节省存储空间。</li> <li>【建议】业务中IP地址字段推荐使用<code class="language-plaintext highlighter-rouge">int</code>类型，不推荐用<code class="language-plaintext highlighter-rouge">char(15)</code>。因为<code class="language-plaintext highlighter-rouge">int</code>只占4字节，可以用如下函数相互转换，而<code class="language-plaintext highlighter-rouge">char(15)</code>占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。 SQL：<code class="language-plaintext highlighter-rouge">select inet_aton('192.168.2.12'); select inet_ntoa(3232236044);</code> PHP: <code class="language-plaintext highlighter-rouge">ip2long(‘192.168.2.12’); long2ip(3530427185);</code></li> <li>【建议】不推荐使用<code class="language-plaintext highlighter-rouge">enum</code>，<code class="language-plaintext highlighter-rouge">set</code>。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用<code class="language-plaintext highlighter-rouge">tinyint</code>或<code class="language-plaintext highlighter-rouge">smallint</code>。</li> <li>【建议】不推荐使用<code class="language-plaintext highlighter-rouge">blob</code>，<code class="language-plaintext highlighter-rouge">text</code>等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段。Innodb中当一行记录超过8098字节时，会将该记录中选取最长的一个字段将其768字节放在原始page里，该字段余下内容放在<code class="language-plaintext highlighter-rouge">overflow-page</code>里。不幸的是在<code class="language-plaintext highlighter-rouge">compact</code>行格式下，原始<code class="language-plaintext highlighter-rouge">page</code>和<code class="language-plaintext highlighter-rouge">overflow-page</code>都会加载。</li> <li>【建议】存储金钱的字段，建议用<code class="language-plaintext highlighter-rouge">int</code>，程序端乘以100和除以100进行存取。因为<code class="language-plaintext highlighter-rouge">int</code>占用4字节，而<code class="language-plaintext highlighter-rouge">double</code>占用8字节，空间浪费。</li> <li>【建议】文本数据尽量用<code class="language-plaintext highlighter-rouge">varchar</code>存储。因为<code class="language-plaintext highlighter-rouge">varchar</code>是变长存储，比<code class="language-plaintext highlighter-rouge">char</code>更省空间。MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为<code class="language-plaintext highlighter-rouge">mediumtext</code>字段。而<code class="language-plaintext highlighter-rouge">text</code>在utf8字符集下最多存21844个字符，<code class="language-plaintext highlighter-rouge">mediumtext</code>最多存2^24/3个字符，<code class="language-plaintext highlighter-rouge">longtext</code>最多存2^32个字符。一般建议用<code class="language-plaintext highlighter-rouge">varchar</code>类型，字符数不要超过2700。</li> <li>【建议】时间类型尽量选取<code class="language-plaintext highlighter-rouge">timestamp</code>。因为<code class="language-plaintext highlighter-rouge">datetime</code>占用8字节，<code class="language-plaintext highlighter-rouge">timestamp</code>仅占用4字节，但是范围为<code class="language-plaintext highlighter-rouge">1970-01-01 00:00:01</code>到<code class="language-plaintext highlighter-rouge">2038-01-01 00:00:00</code>。更为高阶的方法，选用<code class="language-plaintext highlighter-rouge">int</code>来存储时间，使用SQL函数<code class="language-plaintext highlighter-rouge">unix_timestamp()</code>和<code class="language-plaintext highlighter-rouge">from_unixtime()</code>来进行转换。</li> </ol> <p>详细存储大小参见如下链接：</p> <p><a href="https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html">MySQL数据类型存储大小</a></p> <h3 id="214-索引设计">2.1.4 索引设计</h3> <ol> <li>【强制】InnoDB表必须主键为<code class="language-plaintext highlighter-rouge">id int/bigint auto_increment</code>,且主键值禁止被更新。</li> <li>【建议】主键的名称以“<code class="language-plaintext highlighter-rouge">pk_</code>”开头，唯一键以“<code class="language-plaintext highlighter-rouge">uk_</code>”或“<code class="language-plaintext highlighter-rouge">uq_</code>”开头，普通索引以“<code class="language-plaintext highlighter-rouge">idx_</code>”开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀。</li> <li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code class="language-plaintext highlighter-rouge">BTREE</code>；MEMORY表可以根据需要选择<code class="language-plaintext highlighter-rouge">HASH</code>或者<code class="language-plaintext highlighter-rouge">BTREE</code>类型索引。</li> <li>【强制】单个索引中每个索引记录的长度不能超过64KB。</li> <li>【建议】单个表上的索引个数不能超过7个。</li> <li>【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列<code class="language-plaintext highlighter-rouge">userid</code>的区分度可由<code class="language-plaintext highlighter-rouge">select count(distinct userid)</code>计算出来。</li> <li>【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</li> <li>【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在<code class="language-plaintext highlighter-rouge">key(a,b)</code>，则<code class="language-plaintext highlighter-rouge">key(a)</code>为冗余索引，需要删除。</li> </ol> <h3 id="215-分库分表分区表">2.1.5 分库分表、分区表</h3> <ol> <li>【强制】分区表的分区字段（<code class="language-plaintext highlighter-rouge">partition-key</code>）必须有索引，或者是组合索引的首列。</li> <li>【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</li> <li>【强制】上线前RD或者DBA必须指定分区表的创建、清理策略。</li> <li>【强制】访问分区表的SQL必须包含分区键。</li> <li>【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个。</li> <li>【强制】对于分区表执行<code class="language-plaintext highlighter-rouge">alter table</code>操作，必须在业务低峰期执行。</li> <li>【强制】采用分库策略的，库的数量不能超过1024</li> <li>【强制】采用分表策略的，表的数量不能超过4096</li> <li>【建议】单个分表不超过500W行，ibd文件大小不超过2G，这样才能让数据分布式变得性能更佳。</li> <li>【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。</li> </ol> <h3 id="216-字符集">2.1.6 字符集</h3> <ol> <li>【强制】数据库本身库、表、列所有字符集必须保持一致，为<code class="language-plaintext highlighter-rouge">utf8</code>或<code class="language-plaintext highlighter-rouge">utf8mb4</code>。</li> <li>【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为<code class="language-plaintext highlighter-rouge">utf8</code>。</li> </ol> <h3 id="217-程序层dao设计建议">2.1.7 程序层DAO设计建议</h3> <ol> <li>【建议】新的代码不要用model，推荐使用手动拼SQL+绑定变量传入参数的方式。因为model虽然可以使用面向对象的方式操作db，但是其使用不当很容易造成生成的SQL非常复杂，且model层自己做的强制类型转换性能较差，最终导致数据库性能下降。</li> <li>【建议】前端程序连接MySQL或者redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。</li> <li>【建议】前端程序报错里尽量能够提示MySQL或redis原生态的报错信息，便于排查错误。</li> <li>【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。</li> <li>【建议】对于log或history类型的表，随时间增长容易越来越大，因此上线前RD或者DBA必须建立表数据清理或归档方案。</li> <li>【建议】在应用程序设计阶段，RD必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。</li> <li>【建议】多个并发业务逻辑访问同一块数据（innodb表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类SQL尽量基于主键去更新。</li> <li>【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。</li> <li>【建议】对于单表读写比大于10:1的数据行或单个列，可以将热点数据放在缓存里（如mecache或redis），加快访问速度，降低MySQL压力。</li> </ol> <h3 id="218-一个规范的建表语句示例">2.1.8 一个规范的建表语句示例</h3> <p>一个较为规范的建表语句为：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>CREATE TABLE user (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(11) NOT NULL COMMENT ‘用户id’
  `username` varchar(45) NOT NULL COMMENT '真实姓名',
  `email` varchar(30) NOT NULL COMMENT ‘用户邮箱’,
  `nickname` varchar(45) NOT NULL COMMENT '昵称',
  `avatar` int(11) NOT NULL COMMENT '头像',
  `birthday` date NOT NULL COMMENT '生日',
  `sex` tinyint(4) DEFAULT '0' COMMENT '性别',
  `short_introduce` varchar(150) DEFAULT NULL COMMENT '一句话介绍自己，最多50个汉字',
  `user_resume` varchar(300) NOT NULL COMMENT '用户提交的简历存放地址',
  `user_register_ip` int NOT NULL COMMENT ‘用户注册时的源ip’,
  `create_time` timestamp NOT NULL COMMENT ‘用户记录创建的时间’,
  `update_time` timestamp NOT NULL COMMENT ‘用户资料修改的时间’,
  `user_review_status` tinyint NOT NULL COMMENT ‘用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核’,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_id` (`user_id`),
  KEY `idx_username`(`username`),
  KEY `idx_create_time`(`create_time`,`user_review_status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='网站用户基本信息';
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="22-sql编写">2.2 SQL编写</h2> <h3 id="221-dml语句">2.2.1 DML语句</h3> <ol> <li>【强制】SELECT语句必须指定具体字段名称，禁止写成<code class="language-plaintext highlighter-rouge">*</code>。因为<code class="language-plaintext highlighter-rouge">select *</code>会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但model层没有来得及更新的话，系统会报错。</li> <li>【强制】insert语句指定具体字段名称，不要写成<code class="language-plaintext highlighter-rouge">insert into t1 values(…)</code>，道理同上。</li> <li>【建议】<code class="language-plaintext highlighter-rouge">insert into…values(XX),(XX),(XX)…</code>。这里XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。</li> <li>【建议】SELECT语句不要使用<code class="language-plaintext highlighter-rouge">UNION</code>，推荐使用<code class="language-plaintext highlighter-rouge">UNION ALL</code>，并且<code class="language-plaintext highlighter-rouge">UNION</code>子句个数限制在5个以内。因为<code class="language-plaintext highlighter-rouge">union all</code>不需要去重，节省数据库资源，提高性能。</li> <li>【建议】in值列表限制在500以内。例如<code class="language-plaintext highlighter-rouge">select… where userid in(….500个以内…)</code>，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</li> <li>【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。</li> <li>【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。</li> <li>【强制】写入和事务发往主库，只读SQL发往从库。</li> <li>【强制】除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。</li> <li>【强制】生产环境禁止使用<code class="language-plaintext highlighter-rouge">hint</code>，如<code class="language-plaintext highlighter-rouge">sql_no_cache</code>，<code class="language-plaintext highlighter-rouge">force index</code>，<code class="language-plaintext highlighter-rouge">ignore key</code>，<code class="language-plaintext highlighter-rouge">straight join</code>等。因为<code class="language-plaintext highlighter-rouge">hint</code>是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信MySQL优化器！</li> <li>【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</li> <li>【建议】<code class="language-plaintext highlighter-rouge">SELECT|UPDATE|DELETE|REPLACE</code>要有WHERE子句，且WHERE子句的条件必需使用索引查找。</li> <li>【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引。</li> <li>【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</li> <li>【建议】索引列不要使用函数或表达式，否则无法利用索引。如<code class="language-plaintext highlighter-rouge">where length(name)='Admin'</code>或<code class="language-plaintext highlighter-rouge">where user_id+2=10023</code>。</li> <li>【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如<code class="language-plaintext highlighter-rouge">where a=1 or b=2</code>优化为<code class="language-plaintext highlighter-rouge">where a=1… union …where b=2, key(a),key(b)</code>。</li> <li>【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如<code class="language-plaintext highlighter-rouge">select a,b,c from t1 limit 10000,20;</code>优化为: <code class="language-plaintext highlighter-rouge">select a,b,c from t1 where id&gt;10000 limit 20;</code>。</li> </ol> <h3 id="222-多表连接">2.2.2 多表连接</h3> <ol> <li>【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。</li> <li>【强制】禁止在业务的更新类SQL语句中使用join，比如<code class="language-plaintext highlighter-rouge">update t1 join t2…</code>。</li> <li>【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</li> <li>【建议】线上环境，多表join不要超过3个表。</li> <li>【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如<code class="language-plaintext highlighter-rouge">select a from db1.table1 alias1 where …</code>。</li> <li>【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</li> </ol> <h3 id="223-事务">2.2.3 事务</h3> <ol> <li>【建议】事务中<code class="language-plaintext highlighter-rouge">INSERT|UPDATE|DELETE|REPLACE</code>语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内。</li> <li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值5-10秒。</li> <li>【建议】对于有<code class="language-plaintext highlighter-rouge">auto_increment</code>属性字段的表的插入操作，并发需要控制在200以内。</li> <li>【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为<code class="language-plaintext highlighter-rouge">repeatable-read</code>。</li> <li>【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。</li> <li>【建议】事务里更新语句尽量基于主键或<code class="language-plaintext highlighter-rouge">unique key</code>，如<code class="language-plaintext highlighter-rouge">update … where id=XX</code>; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li> <li>【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。</li> <li>【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库。</li> </ol> <h3 id="224-排序和分组">2.2.4 排序和分组</h3> <ol> <li>【建议】减少使用<code class="language-plaintext highlighter-rouge">order by</code>，和业务沟通能不排序就不排序，或将排序放到程序端去做。<code class="language-plaintext highlighter-rouge">order by</code>、<code class="language-plaintext highlighter-rouge">group by</code>、<code class="language-plaintext highlighter-rouge">distinct</code>这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li> <li>【建议】<code class="language-plaintext highlighter-rouge">order by</code>、<code class="language-plaintext highlighter-rouge">group by</code>、<code class="language-plaintext highlighter-rouge">distinct</code>这些SQL尽量利用索引直接检索出排序好的数据。如<code class="language-plaintext highlighter-rouge">where a=1 order by</code>可以利用<code class="language-plaintext highlighter-rouge">key(a,b)</code>。</li> <li>【建议】包含了<code class="language-plaintext highlighter-rouge">order by</code>、<code class="language-plaintext highlighter-rouge">group by</code>、<code class="language-plaintext highlighter-rouge">distinct</code>这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li> </ol> <h3 id="225-线上禁止使用的sql语句">2.2.5 线上禁止使用的SQL语句</h3> <ol> <li>【高危】禁用<code class="language-plaintext highlighter-rouge">update|delete t1 … where a=XX limit XX;</code> 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上<code class="language-plaintext highlighter-rouge">order by PK</code>。</li> <li>【高危】禁止使用关联子查询，如<code class="language-plaintext highlighter-rouge">update t1 set … where name in(select name from user where…);</code>效率极其低下。</li> <li>【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。</li> <li>【强制】禁用<code class="language-plaintext highlighter-rouge">insert into …on duplicate key update…</code>在高并发环境下，会造成主从不一致。</li> <li>【强制】禁止联表更新语句，如<code class="language-plaintext highlighter-rouge">update t1,t2 where t1.id=t2.id…</code>。</li> </ol>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="mysql"/><summary type="html"><![CDATA[MySQL数据库设计规范 原地址参见https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md 目录]]></summary></entry><entry><title type="html">MySQL数据库设计规范</title><link href="https://devsong.github.io/blog/2021/07/002-sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" rel="alternate" type="text/html" title="MySQL数据库设计规范"/><published>2021-07-05T10:31:04+08:00</published><updated>2021-07-05T10:31:04+08:00</updated><id>https://devsong.github.io/blog/2021/07/002-sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F</id><content type="html" xml:base="https://devsong.github.io/blog/2021/07/002-sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"><![CDATA[<h3 id="sql基础篇">Sql基础篇</h3> <p>- <strong>背景:</strong>不同于传统程序的顺序执行流程,初中级的developer通常对于SQL的的具体执行逻辑、顺序感到困惑,基本刚入门的后端程序员都有类似的问题,对与程序(SQL)的具体执行流程有一个清晰的执行流程是一个合格程序员必备的技能,下面对与SQL的执行顺序做一个基本的介绍,</p> <p><strong>注意下面介绍的是SQL执行的逻辑顺序,目的是帮助大家认识清楚SQL的基础的执行流程,此处暂不涉及任何索引的相关的内容</strong></p> <p>下文所有的示例均基于MySql进行讲解,此处不涉及到各个数据库特有的功能(rollup/cube等,分页例外,毕竟每个数据库(Mysql/oracle/sqlserver)对与分页的语法不一样,而分页是一个非常常用的功能)</p> <ul> <li> <p>SQL执行顺序(逻辑顺序)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>  (7) SELECT (8)DISTINCT&lt;Select_field_list&gt;
  (1) FROM &lt;left_table&gt; (3) &lt;join_type&gt;JOIN&lt;right_table&gt;
  (2) ON&lt;join_condition&gt;
  (4) WHERE&lt;where_condition&gt;
  (5) GROUP BY&lt;group_by_list&gt;
  (6) HAVING&lt;having_condtion&gt;
  (9) ORDER BY&lt;order_by_list&gt;
  (10) LIMIT&lt;limit_number&gt;
</pre></td></tr></tbody></table></code></pre></div> </div> <ul> <li><strong>步骤1:</strong>From后面的字句通常是第一步,目的是在系统中定位到具体的表/试图,不存在此处直接抛出异常,对与left_table与right_table做笛卡尔积,生成一个基础的表vt1(virtual_table1)</li> <li><strong>步骤2:</strong>on 条件,left 与right关联关系的条件列,将on中的逻辑表达式应用于vt1的各个行,得到vt2</li> <li><strong>步骤3:</strong>join 根据join_type的类型,做对应的处理,此处会添加额外的行 <ul> <li>left (out) join ,left_table作为保留表,将第2步中过滤的行添加进来</li> <li>right(out) join,right_table作为保留表,同样将第2步中过滤的行添加进来</li> </ul> <p>生成vt3,如果from谓词后面的表多余2个,将vt3继续与后面的表做链接,重复上述三个步骤,得到最终的vt3</p> </li> <li><strong>步骤4:</strong>对vt3应用where筛选条件,得到vt4,对与inner join,on 和where的条件并无区别,对与outer join,此处就需要注意了,<strong>由于步骤3会基于保留表(取决于join类型)添加额外的行,所以on条件中的过滤会被添加回来来,而针对于where子句中的条件过滤,是对最终结果集的过滤,此处的筛选移除是无法被添加进来</strong>。</li> <li><strong>步骤5:</strong>group by 子句针对vt4,应用具体的分组条件,通俗点就是将group by后拥有相同行内容的数据进行规整(count/max/min/avg等),得到vt5</li> <li><strong>步骤6:</strong>基于vt5应用having子句(可以简单理解为进一步的where筛选,通常是基于分组函数的值进行过滤),针对vt5的结果集做进一步的过滤,得到vt6</li> <li><strong>步骤7:</strong>基于vt6,执行select语句,取出具体的数据列,得到vt7</li> <li><strong>步骤8:</strong>基于vt7执行distinct,对结果集进行去重,得到vt8</li> <li><strong>步骤9:</strong>基于vt8,执行具体的排序操作,生成vt9</li> <li><strong>步骤10:</strong>基于vt9,执行具体的分页操作,生成vt10,vt10即为最终的结果集,返回给调用方</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="blogs"/><category term="blogs"/><category term="mysql"/><summary type="html"><![CDATA[Sql基础篇 - 背景:不同于传统程序的顺序执行流程,初中级的developer通常对于SQL的的具体执行逻辑、顺序感到困惑,基本刚入门的后端程序员都有类似的问题,对与程序(SQL)的具体执行流程有一个清晰的执行流程是一个合格程序员必备的技能,下面对与SQL的执行顺序做一个基本的介绍,]]></summary></entry></feed>